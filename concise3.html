<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spell Chess</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" integrity="sha512-BNaRQnYJYiPSqHHDb58B0yaPfCu+Wgds8Gp/gU33kqBtgNS4tSPHuGibyoeqMV/TJlSKda6FXzoEyYGjTe+vXA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    
    <style>
        /* Global reset/base */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            box-sizing: border-box;
        }
        *, *:before, *:after {
            box-sizing: inherit;
        }

        /* Styles for home page view */
        body.home-view {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            min-height: 100vh;
            padding: 20px;
        }
        body.home-view #game-content-wrapper {
            display: none;
        }
        body.home-view #announcement-box { 
            display: none;
        }
        body.home-view #home-page-content {
            display: block;
        }

        /* Styles for game view (Desktop First) */
        body.game-view {
            display: flex;
            flex-direction: column; 
            align-items: center; 
            padding: 20px;
            background-color: #fff;
            min-height: 100vh;
        }
        body.game-view #home-page-content {
            display: none;
        }
        body.game-view #game-content-wrapper {
            display: block; 
        }
         body.game-view #announcement-box { 
            display: block; 
            width: 100%;
            max-width: 1100px; 
            margin: 0 auto 20px auto; 
            padding: 15px;
            border: 2px solid #007bff;
            background-color: #e7f3ff;
            border-radius: 8px;
            text-align: center;
            font-size: 0.95em;
            line-height: 1.6;
        }
        #announcement-box h3 {
            margin-top: 0;
            color: #0056b3;
        }
        #announcement-box a {
            color: #0056b3;
            font-weight: bold;
            text-decoration: none;
        }
        #announcement-box a:hover {
            text-decoration: underline;
        }


        #home-page-content h1 {
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        #start-game-button {
            padding: 15px 30px;
            font-size: 1.2em;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            margin-bottom: 5px;
        }
        #start-game-button:hover {
            background-color: #45a049;
        }

        .game-container {
            display: flex;
            flex-wrap: wrap; 
            gap: 20px;
            align-items: flex-start;
            width: 100%;
            margin: 0 auto;
            justify-content: center;
        }

        .main-game-area { 
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 480px; 
            flex-shrink: 0;
        }
        #mobile-navigation-controls {
            display: none;
        }

        .status-area {
            padding: 10px;
            border: 1px solid #ccc;
            background-color: #e9ecef;
            min-height: 50px;
            width: 100%; 
            text-align: center; 
        }
        .rules-area {
            padding: 10px;
            border: 1px solid #ccc;
            background-color: #f8f9fa;
            width: 100%;
            margin-top: 10px; 
            font-size: 0.9em;
            line-height: 1.5;
        }
        .rules-area h4 {
            margin-top: 0;
            color: #333;
        }
        .rules-area ul {
            padding-left: 20px;
            margin-bottom: 0;
        }
        .rules-area li {
            margin-bottom: 5px;
        }

        .chessboard {
            width: 480px;
            height: 480px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 2px solid #333;
            transition: transform 0.5s;
        }
        .chessboard.flipped {
            transform: rotate(180deg);
        }
        .square {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            cursor: pointer;
            user-select: none;
            position: relative;
        }
        .square.light { background-color: #f0d9b5; }
        .square.dark { background-color: #b58863; }
        .square.selected { background-color: #6a994e; }
        .square.highlight-history {
            box-shadow: inset 0 0 10px 4px rgba(255, 0, 0, 0.6);
        }

        .square.valid-move-hint::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(167, 201, 87, 0.5);
            box-shadow: inset 0 0 0 2px #6a994e;
            z-index: 1;
        }
        .square.active-freeze-zone {
            box-shadow: inset 0 0 0 1000px rgba(173, 216, 230, 0.35);
        }
        .square.jumpable-on-square {
            box-shadow: inset 0 0 0 1000px rgba(255, 255, 0, 0.25),
                        inset 0 0 0 3px #DAA520;
        }
        .square.freeze-outline-top { border-top: 3px solid #007bff; }
        .square.freeze-outline-bottom { border-bottom: 3px solid #007bff; }
        .square.freeze-outline-left { border-left: 3px solid #007bff; }
        .square.freeze-outline-right { border-right: 3px solid #007bff; }

        .square-freeze-emoji {
            position: absolute;
            top: 1px;
            right: 1px;
            font-size: 15px;
            opacity: 0.9;
            z-index: 1;
            pointer-events: none;
        }
        .piece {
            position: relative;
            z-index: 2;
            transition: transform 0.5s;
        }
        .chessboard.flipped .piece {
            transform: rotate(180deg);
        }
        .chessboard.colored-pieces .piece.white-piece-alternative {
            color: white; 
            text-shadow: -1px -1px 0 #555, 1px -1px 0 #555, -1px 1px 0 #555, 1px 1px 0 #555;
        }

        .controls {
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex-shrink: 0;
        }
        .controls.flipped {
            flex-direction: column-reverse;
        }
        .player-info { padding: 10px; border: 1px solid #ccc; border-radius: 5px; }
        .player-info h3 { margin-top: 0; margin-bottom: 5px; text-align: center;}
        .spell-button, .reset-button, .promotion-button { 
            padding: 8px 12px;
            cursor: pointer;
            border: 1px solid #555;
            border-radius: 4px;
            background-color: #f0f0f0;
            width: 100%;
        }
        .promotion-button {
            margin-bottom: 5px;
        }
        .spell-button:disabled, .reset-button:disabled { cursor: not-allowed; background-color: #ccc; color: #777; }
        .spell-button.targeting { background-color: #add8e6; }
        
        .spell-container { margin-bottom: 10px; }
        .spell-icon-container { display: flex; gap: 4px; margin-top: 5px; height: 20px; }
        .spell-icon { font-size: 18px; }
        .cooldown-bar { width: 100%; height: 8px; background-color: #e9ecef; border: 1px solid #ccc; border-radius: 4px; margin-top: 4px; overflow: hidden; }
        .cooldown-bar-fill { height: 100%; background-color: #adb5bd; transition: width 0.3s ease-in-out;}
        .cooldown-bar-fill.jump { background: linear-gradient(to right, #ffc107, #ff9800); }
        .cooldown-bar-fill.freeze { background: linear-gradient(to right, #00bfff, #007bff); }
        .cooldown-bar-fill.ready { background-color: #28a745; }


        #cancel-spell-container { height: 40px; } /* Reserve space to prevent layout shifts */

        #import-game-area {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-top: 10px;
            display: none; /* Hidden by default */
        }
        #import-game-textarea {
            width: 100%;
            min-height: 80px;
            margin-bottom: 10px;
        }
        .import-controls {
            display: flex;
            gap: 10px;
        }

        .navigation-controls {
            display: flex;
            gap: 5px;
            width: 100%;
            flex-wrap: nowrap;
            align-items: center;
        }
        .navigation-controls .nav-button {
            flex: 1;
            padding: 6px;
            font-size: 1.2em;
            font-weight: bold;
        }
        .navigation-controls .icon-button {
            flex: 0 0 auto; /* Don't grow or shrink */
            width: 36px;
            height: 36px;
            padding: 4px;
            font-size: 20px;
        }


        .notation-wrapper {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 360px;
            flex-shrink: 0;
        }

        .notation-area {
            padding: 10px;
            border: 1px solid #ccc;
            height: 240px; /* Reduced height */
            overflow-y: auto;
            resize: vertical; /* Make it resizable */
            background-color: #f8f9fa;
            min-height: 100px;
        }
        .notation-area .notation-line {
            margin-bottom: 2px;
        }
        .notation-area .notation-turn-number {
            font-weight: bold;
            margin-right: 2px; 
        }
        .notation-area .notation-move {
            cursor: pointer;
            text-decoration: underline;
            color: #0056b3;
            margin-right: 5px;
            padding: 2px 4px;
            border-radius: 3px;
        }
        .notation-area .notation-move:hover {
            color: #007bff;
            background-color: #e9ecef;
        }
         .notation-area .notation-move.current-move {
            background-color: #a7c957;
            color: white;
            text-decoration: none;
        }

        #promotion-choices {
            margin-top: 10px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
         #gif-output-area { 
            margin-top: 20px;
            text-align: center;
            width: 100%; 
        }


        /* --- MOBILE STYLES --- */
        @media (max-width: 768px) {
            body.game-view {
                padding: 10px; 
            }
            #announcement-box {
                max-width: 95vw; 
                font-size: 0.85em;
            }
            .game-container {
                flex-direction: column; 
                align-items: center; 
                gap: 15px;
                flex-wrap: nowrap; 
            }
            .main-game-area { 
                 width: 90vw;
                 max-width: 400px; 
                 order: 1; 
                 gap: 10px;
            }
            .chessboard {
                width: 100%; 
                height: auto; 
                aspect-ratio: 1 / 1; 
                max-width: none; 
                max-height: none;
            }
            #mobile-navigation-controls {
                display: flex;
            }
            .notation-wrapper .navigation-controls {
                display: none;
            }
            .status-area {
                 width: 100%; 
                 max-width: none; 
                 text-align: center;
            }
            .rules-area {
                font-size: 0.8em;
            }
            .square {
                font-size: 7vw;
            }
            @media (min-width: 450px) and (max-width: 768px) {
                .square {
                    font-size: 32px;
                }
            }
            .controls {
                order: 2; 
                width: 90vw;
                max-width: 480px;
            }
            .player-info {
                display: flex;
                flex-direction: column;
                align-items: stretch;
            }
             .player-info small {
                display: none; /* Hide text cooldown on mobile */
             }
            .notation-wrapper {
                order: 3;
                width: 90vw;
                max-width: 480px;
            }
            .notation-area {
                height: 150px;
                width: 100%;
            }
             #promotion-choices {
                order: -1;
            }
            #gif-output-area {
                order: 4; 
                width: 90vw;
                max-width: 480px;
            }
        }
        @media (max-width: 400px) {
            .square {
                font-size: 28px;
            }
            .player-info h3 {
                font-size: 1em;
            }
            .spell-button, .reset-button, .promotion-button {
                padding: 6px 10px;
                font-size: 0.9em;
            }
            .main-game-area { 
                width: 95vw; 
            }
            .controls, .notation-wrapper, #gif-output-area {
                 width: 95vw;
            }
        }
    </style>
</head>
<body class="game-view vsc-initialized"> 

    <div id="home-page-content">
        <h1>Spell Chess</h1>
        <button id="start-game-button">Two Player Game</button>
    </div>

    <div id="announcement-box">
        <h3><a href="https://www.chess.com/club/spell-chess-team-game-starting-2025-06-01" target="_blank">Spell Chess Team Game</a></h3>
        <p>
            Start Date: June 1, 2025<br>
            Time Control: 24 Hours Per Move<br>
            Join the club for the <a href="https://www.chess.com/club/white-team-spell-chess-game-2025-06-01" target="_blank">White Team</a> or <a href="https://www.chess.com/club/black-team-spell-chess-game-2025-06-01" target="_blank">Black Team</a> to participate!<br>
            This page is kept up to date with the current position by <a href="https://www.chess.com/member/LongTermFuture" target="_blank">LongTermFuture</a>.
        </p>
    </div>

    <div id="game-content-wrapper">
        <div class="game-container">
            <div class="main-game-area">
                <div id="chessboard" class="chessboard colored-pieces"><div class="square light" data-r="0" data-c="0"><span class="piece" data-piece-id="piece-0-0-1749374889810">‚ôú</span></div><div class="square dark" data-r="0" data-c="1"><span class="piece" data-piece-id="piece-0-1-1749374889810">‚ôû</span></div><div class="square light" data-r="0" data-c="2"><span class="piece" data-piece-id="piece-0-2-1749374889810">‚ôù</span></div><div class="square dark" data-r="0" data-c="3"><span class="piece" data-piece-id="piece-0-3-1749374889810">‚ôõ</span></div><div class="square light" data-r="0" data-c="4"><span class="piece" data-piece-id="piece-0-4-1749374889810">‚ôö</span></div><div class="square dark" data-r="0" data-c="5"><span class="piece" data-piece-id="piece-0-5-1749374889810">‚ôù</span></div><div class="square light" data-r="0" data-c="6"><span class="piece" data-piece-id="piece-0-6-1749374889810">‚ôû</span></div><div class="square dark" data-r="0" data-c="7"><span class="piece" data-piece-id="piece-0-7-1749374889810">‚ôú</span></div><div class="square dark" data-r="1" data-c="0"><span class="piece" data-piece-id="piece-1-0-1749374889810">‚ôü</span></div><div class="square light" data-r="1" data-c="1"><span class="piece" data-piece-id="piece-1-1-1749374889810">‚ôü</span></div><div class="square dark" data-r="1" data-c="2"><span class="piece" data-piece-id="piece-1-2-1749374889810">‚ôü</span></div><div class="square light" data-r="1" data-c="3"><span class="piece" data-piece-id="piece-1-3-1749374889810">‚ôü</span></div><div class="square dark" data-r="1" data-c="4"><span class="piece" data-piece-id="piece-1-4-1749374889810">‚ôü</span></div><div class="square light" data-r="1" data-c="5"><span class="piece" data-piece-id="piece-1-5-1749374889810">‚ôü</span></div><div class="square dark" data-r="1" data-c="6"><span class="piece" data-piece-id="piece-1-6-1749374889810">‚ôü</span></div><div class="square light" data-r="1" data-c="7"><span class="piece" data-piece-id="piece-1-7-1749374889810">‚ôü</span></div><div class="square light" data-r="2" data-c="0"></div><div class="square dark" data-r="2" data-c="1"></div><div class="square light" data-r="2" data-c="2"></div><div class="square dark" data-r="2" data-c="3"></div><div class="square light" data-r="2" data-c="4"></div><div class="square dark" data-r="2" data-c="5"></div><div class="square light" data-r="2" data-c="6"></div><div class="square dark" data-r="2" data-c="7"></div><div class="square dark" data-r="3" data-c="0"></div><div class="square light" data-r="3" data-c="1"></div><div class="square dark" data-r="3" data-c="2"></div><div class="square light" data-r="3" data-c="3"></div><div class="square dark" data-r="3" data-c="4"></div><div class="square light" data-r="3" data-c="5"></div><div class="square dark" data-r="3" data-c="6"></div><div class="square light" data-r="3" data-c="7"></div><div class="square light" data-r="4" data-c="0"></div><div class="square dark" data-r="4" data-c="1"></div><div class="square light" data-r="4" data-c="2"></div><div class="square dark" data-r="4" data-c="3"></div><div class="square light" data-r="4" data-c="4"></div><div class="square dark" data-r="4" data-c="5"></div><div class="square light" data-r="4" data-c="6"></div><div class="square dark" data-r="4" data-c="7"></div><div class="square dark" data-r="5" data-c="0"></div><div class="square light" data-r="5" data-c="1"></div><div class="square dark" data-r="5" data-c="2"></div><div class="square light" data-r="5" data-c="3"></div><div class="square dark" data-r="5" data-c="4"></div><div class="square light" data-r="5" data-c="5"></div><div class="square dark" data-r="5" data-c="6"></div><div class="square light" data-r="5" data-c="7"></div><div class="square light" data-r="6" data-c="0"><span class="piece white-piece-alternative" data-piece-id="piece-6-0-1749374889810">‚ôü</span></div><div class="square dark" data-r="6" data-c="1"><span class="piece white-piece-alternative" data-piece-id="piece-6-1-1749374889810">‚ôü</span></div><div class="square light" data-r="6" data-c="2"><span class="piece white-piece-alternative" data-piece-id="piece-6-2-1749374889810">‚ôü</span></div><div class="square dark" data-r="6" data-c="3"><span class="piece white-piece-alternative" data-piece-id="piece-6-3-1749374889810">‚ôü</span></div><div class="square light" data-r="6" data-c="4"><span class="piece white-piece-alternative" data-piece-id="piece-6-4-1749374889810">‚ôü</span></div><div class="square dark" data-r="6" data-c="5"><span class="piece white-piece-alternative" data-piece-id="piece-6-5-1749374889810">‚ôü</span></div><div class="square light" data-r="6" data-c="6"><span class="piece white-piece-alternative" data-piece-id="piece-6-6-1749374889810">‚ôü</span></div><div class="square dark" data-r="6" data-c="7"><span class="piece white-piece-alternative" data-piece-id="piece-6-7-1749374889810">‚ôü</span></div><div class="square dark" data-r="7" data-c="0"><span class="piece white-piece-alternative" data-piece-id="piece-7-0-1749374889810">‚ôú</span></div><div class="square light" data-r="7" data-c="1"><span class="piece white-piece-alternative" data-piece-id="piece-7-1-1749374889810">‚ôû</span></div><div class="square dark" data-r="7" data-c="2"><span class="piece white-piece-alternative" data-piece-id="piece-7-2-1749374889810">‚ôù</span></div><div class="square light" data-r="7" data-c="3"><span class="piece white-piece-alternative" data-piece-id="piece-7-3-1749374889810">‚ôõ</span></div><div class="square dark" data-r="7" data-c="4"><span class="piece white-piece-alternative" data-piece-id="piece-7-4-1749374889810">‚ôö</span></div><div class="square light" data-r="7" data-c="5"><span class="piece white-piece-alternative" data-piece-id="piece-7-5-1749374889810">‚ôù</span></div><div class="square dark" data-r="7" data-c="6"><span class="piece white-piece-alternative" data-piece-id="piece-7-6-1749374889810">‚ôû</span></div><div class="square light" data-r="7" data-c="7"><span class="piece white-piece-alternative" data-piece-id="piece-7-7-1749374889810">‚ôú</span></div></div> 
                 <div id="mobile-navigation-controls" class="navigation-controls">
                    <button id="history-back-button-mobile" class="reset-button nav-button" disabled="">&lt;</button>
                    <button id="history-forward-button-mobile" class="reset-button nav-button" disabled="">&gt;</button>
                    <button id="copy-notation-button-mobile" class="reset-button icon-button">üìã</button>
                </div>
                <div id="status-area" class="status-area">White's turn.</div>
                <div id="rules-area" class="rules-area">
                    <h4>Spell Chess Rules:</h4>
                    <ul>
                        <li>Standard chess rules apply, with the exception that capturing the opponent's king is a legal move even if your own king is in check.</li>
                        <li>Each player starts with two Jump spells and five Freeze spells.</li>
                        <li>A player may cast a spell before making their move.</li>
                        <li><strong>Jump Spell:</strong> Target any piece. For your current move and your opponent's next move, that piece is jumpable by other pieces as if it is not there.</li>
                        <li><strong>Freeze Spell:</strong> Target any square. All pieces in a 3x3 area around the target square are frozen and cannot move on your turn or your opponent's next turn. Frozen pieces cannot put a king in check or checkmate.</li>
                        <li>Spells have a 3-turn cooldown before they can be used again.</li>
                        <li>Checkmate or capture your opponent's king to win.</li>
                    </ul>
                </div>
            </div>
            <div class="controls">
                <div id="black-player-info" class="player-info">
                    <h3>Black</h3>
                    <div class="spell-container">
                        <button id="black-jump-spell" class="spell-button" disabled="">Cast Jump (<span id="black-jump-count">2</span>)</button>
                        <div class="cooldown-bar"><div id="black-jump-cooldown-bar" class="cooldown-bar-fill jump ready" style="width: 100%;"></div></div>
                        <small id="black-jump-cooldown">Ready</small>
                        <div id="black-jump-icons" class="spell-icon-container"><span class="spell-icon">‚ö°</span><span class="spell-icon">‚ö°</span></div>
                    </div>
                    <div class="spell-container">
                        <button id="black-freeze-spell" class="spell-button" disabled="">Cast Freeze (<span id="black-freeze-count">5</span>)</button>
                        <div class="cooldown-bar"><div id="black-freeze-cooldown-bar" class="cooldown-bar-fill freeze ready" style="width: 100%;"></div></div>
                        <small id="black-freeze-cooldown">Ready</small>
                        <div id="black-freeze-icons" class="spell-icon-container"><span class="spell-icon">‚ùÑÔ∏è</span><span class="spell-icon">‚ùÑÔ∏è</span><span class="spell-icon">‚ùÑÔ∏è</span><span class="spell-icon">‚ùÑÔ∏è</span><span class="spell-icon">‚ùÑÔ∏è</span></div>
                    </div>
                </div>

                <div id="cancel-spell-container">
                     <button id="cancel-button" class="reset-button" style="display: none;">Cancel Spell</button>
                </div>

                <div id="white-player-info" class="player-info">
                    <h3>White</h3>
                     <div class="spell-container">
                        <button id="white-jump-spell" class="spell-button">Cast Jump (<span id="white-jump-count">2</span>)</button>
                        <div class="cooldown-bar"><div id="white-jump-cooldown-bar" class="cooldown-bar-fill jump ready" style="width: 100%;"></div></div>
                        <small id="white-jump-cooldown">Ready</small>
                        <div id="white-jump-icons" class="spell-icon-container"><span class="spell-icon">‚ö°</span><span class="spell-icon">‚ö°</span></div>
                    </div>
                    <div class="spell-container">
                        <button id="white-freeze-spell" class="spell-button">Cast Freeze (<span id="white-freeze-count">5</span>)</button>
                        <div class="cooldown-bar"><div id="white-freeze-cooldown-bar" class="cooldown-bar-fill freeze ready" style="width: 100%;"></div></div>
                        <small id="white-freeze-cooldown">Ready</small>
                        <div id="white-freeze-icons" class="spell-icon-container"><span class="spell-icon">‚ùÑÔ∏è</span><span class="spell-icon">‚ùÑÔ∏è</span><span class="spell-icon">‚ùÑÔ∏è</span><span class="spell-icon">‚ùÑÔ∏è</span><span class="spell-icon">‚ùÑÔ∏è</span></div>
                    </div>
                </div>
                
                <div id="promotion-choices" style="display:none;">
                    <button class="promotion-button" data-promote="Q">Promote to Queen</button>
                    <button class="promotion-button" data-promote="R">Promote to Rook</button>
                    <button class="promotion-button" data-promote="B">Promote to Bishop</button>
                    <button class="promotion-button" data-promote="N">Promote to Knight</button>
                </div>
            </div>
            <div class="notation-wrapper">
                <div id="notation-area" class="notation-area"></div>
                <div class="navigation-controls">
                    <button id="history-back-button-desktop" class="reset-button nav-button" disabled="">&lt;</button>
                    <button id="history-forward-button-desktop" class="reset-button nav-button" disabled="">&gt;</button>
                    <button id="copy-notation-button-desktop" class="reset-button icon-button">üìã</button>
                </div>
                <button id="get-link-button" class="reset-button">Get Custom Game Link</button>
                <button id="import-game-button" class="reset-button">Import Game</button>
                <div id="import-game-area">
                    <textarea id="import-game-textarea" placeholder="Paste game notation here..."></textarea>
                    <div class="import-controls">
                        <button id="load-game-button" class="reset-button">Load Game</button>
                        <button id="cancel-import-button" class="reset-button">Cancel</button>
                    </div>
                </div>
                <div class="options-dropdown">
                    <button id="options-toggle-button" class="options-button">‚öôÔ∏è Options</button>
                    <div id="options-content" class="dropdown-content">
                        <button id="flip-board-button" class="reset-button">Flip Board</button>
                        <button id="toggle-pieces-button" class="reset-button">Use Standard Pieces</button>
                        <button id="download-game-button" class="reset-button">Download Game</button>
                        <button id="download-gif-button" class="reset-button">Download GIF Frames</button>
                        <button id="reset-game-button" class="reset-button">Reset Game</button>
                        <button id="go-home-button" class="reset-button">Home</button>
                    </div>
                </div>
            </div>
        </div>
        <div id="gif-output-area">
            <!-- Content here if needed -->
        </div>
    </div>

    <script id="savedGameStateData" type="application/json">{"board":[[{"type":"r","color":"black","id":"piece-0-0-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"n","color":"black","id":"piece-0-1-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"b","color":"black","id":"piece-0-2-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"q","color":"black","id":"piece-0-3-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"k","color":"black","id":"piece-0-4-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"b","color":"black","id":"piece-0-5-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"n","color":"black","id":"piece-0-6-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"r","color":"black","id":"piece-0-7-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false}],[{"type":"p","color":"black","id":"piece-1-0-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"p","color":"black","id":"piece-1-1-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"p","color":"black","id":"piece-1-2-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"p","color":"black","id":"piece-1-3-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"p","color":"black","id":"piece-1-4-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"p","color":"black","id":"piece-1-5-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"p","color":"black","id":"piece-1-6-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"p","color":"black","id":"piece-1-7-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false}],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],[{"type":"P","color":"white","id":"piece-6-0-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"P","color":"white","id":"piece-6-1-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"P","color":"white","id":"piece-6-2-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"P","color":"white","id":"piece-6-3-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"P","color":"white","id":"piece-6-4-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"P","color":"white","id":"piece-6-5-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"P","color":"white","id":"piece-6-6-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"P","color":"white","id":"piece-6-7-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false}],[{"type":"R","color":"white","id":"piece-7-0-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"N","color":"white","id":"piece-7-1-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"B","color":"white","id":"piece-7-2-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"Q","color":"white","id":"piece-7-3-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"K","color":"white","id":"piece-7-4-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"B","color":"white","id":"piece-7-5-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"N","color":"white","id":"piece-7-6-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"R","color":"white","id":"piece-7-7-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false}]],"currentPlayer":"white","gameTurnNumber":1,"plyCount":0,"spells":{"white":{"jump":2,"freeze":5,"jumpLastUsedTurn":0,"freezeLastUsedTurn":0},"black":{"jump":2,"freeze":5,"jumpLastUsedTurn":0,"freezeLastUsedTurn":0}},"activeSpells":[],"selectedPiece":null,"spellMode":null,"spellCaster":null,"spellActivationState":null,"pendingSpellNotation":null,"moveLog":[],"enPassantTarget":null,"castlingRights":{"white":{"K":true,"Q":true},"black":{"k":true,"q":true}},"isGameOver":false,"gameEndMessage":"","awaitingPromotion":null,"history":[{"board":[[{"type":"r","color":"black","id":"piece-0-0-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"n","color":"black","id":"piece-0-1-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"b","color":"black","id":"piece-0-2-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"q","color":"black","id":"piece-0-3-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"k","color":"black","id":"piece-0-4-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"b","color":"black","id":"piece-0-5-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"n","color":"black","id":"piece-0-6-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"r","color":"black","id":"piece-0-7-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false}],[{"type":"p","color":"black","id":"piece-1-0-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"p","color":"black","id":"piece-1-1-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"p","color":"black","id":"piece-1-2-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"p","color":"black","id":"piece-1-3-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"p","color":"black","id":"piece-1-4-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"p","color":"black","id":"piece-1-5-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"p","color":"black","id":"piece-1-6-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"p","color":"black","id":"piece-1-7-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false}],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],[{"type":"P","color":"white","id":"piece-6-0-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"P","color":"white","id":"piece-6-1-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"P","color":"white","id":"piece-6-2-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"P","color":"white","id":"piece-6-3-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"P","color":"white","id":"piece-6-4-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"P","color":"white","id":"piece-6-5-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"P","color":"white","id":"piece-6-6-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"P","color":"white","id":"piece-6-7-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false}],[{"type":"R","color":"white","id":"piece-7-0-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"N","color":"white","id":"piece-7-1-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"B","color":"white","id":"piece-7-2-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"Q","color":"white","id":"piece-7-3-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"K","color":"white","id":"piece-7-4-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"B","color":"white","id":"piece-7-5-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"N","color":"white","id":"piece-7-6-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false},{"type":"R","color":"white","id":"piece-7-7-1749374889810","isFrozen":false,"isJumpable":false,"hasMoved":false}]],"currentPlayer":"white","gameTurnNumber":1,"plyCount":0,"spells":{"white":{"jump":2,"freeze":5,"jumpLastUsedTurn":0,"freezeLastUsedTurn":0},"black":{"jump":2,"freeze":5,"jumpLastUsedTurn":0,"freezeLastUsedTurn":0}},"activeSpells":[],"selectedPiece":null,"spellMode":null,"spellCaster":null,"spellActivationState":null,"pendingSpellNotation":null,"moveLog":[],"enPassantTarget":null,"castlingRights":{"white":{"K":true,"Q":true},"black":{"k":true,"q":true}},"isGameOver":false,"gameEndMessage":"","awaitingPromotion":null,"useStandardPieces":false,"currentHistoryViewIndex":0}],"useStandardPieces":false,"currentHistoryViewIndex":0,"repetitionCounter":{"rnbqkbnr/pppppppp/        /        /        /        /PPPPPPPP/RNBQKBNR|white|{\"white\":{\"K\":true,\"Q\":true},\"black\":{\"k\":true,\"q\":true}}|null|0,0,0,0":1}}</script>

    <script id="home-page-script">
        const startGameButton = document.getElementById('start-game-button');
        const goHomeButton = document.getElementById('go-home-button');
        const mainBody = document.body;

        startGameButton.addEventListener('click', function() {
            mainBody.classList.remove('home-view');
            mainBody.classList.add('game-view');
            if (typeof resetGame === 'function') { 
                resetGame(true);
            }
        });

        goHomeButton.addEventListener('click', function() {
            mainBody.classList.remove('game-view');
            mainBody.classList.add('home-view');
        });
    </script>

    <script id="spell-chess-game-script">
        const PIECES = {
            'P': '‚ôô', 'R': '‚ôñ', 'N': '‚ôò', 'B': '‚ôó', 'Q': '‚ôï', 'K': '‚ôî',
            'p': '‚ôü', 'r': '‚ôú', 'n': '‚ôû', 'b': '‚ôù', 'q': '‚ôõ', 'k': '‚ôö'
        };
        const B64_URL_SAFE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';

        let useStandardPieces = false; 
        let isBoardFlipped = false;

        const initialBoardSetup = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];

        let gameState;
        let initialGameDataFromSave = null;

        const chessboardDiv = document.getElementById('chessboard');
        const controlsDiv = document.querySelector('.controls');
        const statusArea = document.getElementById('status-area');
        const notationArea = document.getElementById('notation-area');
        const cancelButton = document.getElementById('cancel-button'); 
        const promotionChoicesDiv = document.getElementById('promotion-choices');
        
        const historyBackButtons = [document.getElementById('history-back-button-desktop'), document.getElementById('history-back-button-mobile')];
        const historyForwardButtons = [document.getElementById('history-forward-button-desktop'), document.getElementById('history-forward-button-mobile')];
        const copyNotationButtons = [document.getElementById('copy-notation-button-desktop'), document.getElementById('copy-notation-button-mobile')];
        
        const getLinkButton = document.getElementById('get-link-button');
        const importGameButton = document.getElementById('import-game-button');
        const importGameArea = document.getElementById('import-game-area');
        const loadGameButton = document.getElementById('load-game-button');
        const cancelImportButton = document.getElementById('cancel-import-button');
        const importGameTextarea = document.getElementById('import-game-textarea');
        const optionsToggleButton = document.getElementById('options-toggle-button');
        const optionsContent = document.getElementById('options-content');
        const flipBoardButton = document.getElementById('flip-board-button');

        function coordToB64(r, c) {
            return B64_URL_SAFE_CHARS[r * 8 + c];
        }

        function b64ToCoord(char) {
            const index = B64_URL_SAFE_CHARS.indexOf(char);
            if (index === -1) return null;
            return { r: Math.floor(index / 8), c: index % 8 };
        }

        function deepCopyGameStateForSnapshot(sourceState) { 
            if (!sourceState) return null;
            const target = {};
            for (const key in sourceState) {
                if (Object.prototype.hasOwnProperty.call(sourceState, key)) {
                    if (key === 'history' || key === 'moveLog' || key === 'repetitionCounter') { 
                        continue; 
                    }
                    const value = sourceState[key];
                    if (typeof value === 'object' && value !== null) {
                        target[key] = JSON.parse(JSON.stringify(value));
                    } else {
                        target[key] = value;
                    }
                }
            }
            return target;
        }
        
        function deepCopyFullState(sourceState) {
            return JSON.parse(JSON.stringify(sourceState));
        }

        function initializeGameState() {
            gameState = {
                board: [],
                currentPlayer: 'white',
                gameTurnNumber: 1,
                plyCount: 0, 
                spells: {
                    white: { jump: 2, freeze: 5, jumpLastUsedTurn: 0, freezeLastUsedTurn: 0 },
                    black: { jump: 2, freeze: 5, jumpLastUsedTurn: 0, freezeLastUsedTurn: 0 }
                },
                activeSpells: [],
                selectedPiece: null,
                spellMode: null,
                spellCaster: null,
                spellActivationState: null,
                pendingSpellNotation: null,
                moveLog: [], 
                enPassantTarget: null,
                castlingRights: {
                    white: { K: true, Q: true },
                    black: { k: true, q: true }
                },
                isGameOver: false,
                gameEndMessage: "", 
                awaitingPromotion: null,
                history: [],
                useStandardPieces: false,
                currentHistoryViewIndex: 0,
                repetitionCounter: {}
            };
        }

        function initializeBoardState() {
            gameState.board = initialBoardSetup.map((row, r) =>
                row.map((pieceType, c) => {
                    if (!pieceType) return null;
                    const color = (pieceType === pieceType.toUpperCase()) ? 'white' : 'black';
                    return {
                        type: pieceType,
                        color: color,
                        id: `piece-${r}-${c}-${Date.now()}`, 
                        isFrozen: false,
                        isJumpable: false,
                        hasMoved: false
                    };
                })
            );
        }

        function resetGame(forceNewGame = false) {
            isBoardFlipped = false;
            applyBoardFlip();
            
            if (!forceNewGame && initialGameDataFromSave) {
                gameState = deepCopyFullState(initialGameDataFromSave); 
                useStandardPieces = gameState.useStandardPieces === undefined ? false : gameState.useStandardPieces; 
                if (gameState.currentHistoryViewIndex === undefined) {
                    gameState.currentHistoryViewIndex = gameState.history.length - 1;
                }
                if (gameState.repetitionCounter === undefined) {
                    gameState.repetitionCounter = {};
                }
                initialGameDataFromSave = null; 
                console.log("Game loaded from saved state.");
                document.body.classList.remove('home-view');
                document.body.classList.add('game-view');
                 // Load the state pointed to by the history index
                loadStateFromHistory(gameState.currentHistoryViewIndex, true);
            } else {
                initializeGameState();
                initializeBoardState();
                const initialSnapshot = deepCopyGameStateForSnapshot(gameState); 
                gameState.history.push(initialSnapshot);
                const signature = generateStateSignature(initialSnapshot);
                gameState.repetitionCounter[signature] = 1;
                gameState.currentHistoryViewIndex = 0;
                console.log("New game started.");
                loadStateFromHistory(0, true);
            }
        }
        
        function applyPieceStyle() {
            if (useStandardPieces) {
                chessboardDiv.classList.remove('colored-pieces');
                document.getElementById('toggle-pieces-button').textContent = "Use Colored Pieces";
            } else {
                chessboardDiv.classList.add('colored-pieces');
                document.getElementById('toggle-pieces-button').textContent = "Use Standard Pieces";
            }
            if(gameState && gameState.board && gameState.board.length > 0) { 
               renderBoard();
            }
        }
        
        function applyBoardFlip() {
            chessboardDiv.classList.toggle('flipped', isBoardFlipped);
            controlsDiv.classList.toggle('flipped', isBoardFlipped);
        }

        function handleFlipBoard() {
            isBoardFlipped = !isBoardFlipped;
            applyBoardFlip();
        }

        flipBoardButton.addEventListener('click', handleFlipBoard);
        
        document.getElementById('toggle-pieces-button').addEventListener('click', () => {
            useStandardPieces = !useStandardPieces;
            gameState.useStandardPieces = useStandardPieces; 
            applyPieceStyle();
        });

        document.getElementById('reset-game-button').addEventListener('click', () => resetGame(true)); 
        cancelButton.addEventListener('click', handleCancelAction); 
        historyBackButtons.forEach(btn => btn.addEventListener('click', handleHistoryBack));
        historyForwardButtons.forEach(btn => btn.addEventListener('click', handleHistoryForward));

        promotionChoicesDiv.addEventListener('click', function(event) {
            if (event.target.classList.contains('promotion-button') && gameState.awaitingPromotion) {
                const chosenPieceType = event.target.dataset.promote;
                const { r, c, color, originalMoveNotation, movingPiece, fromR, fromC } = gameState.awaitingPromotion;

                gameState.board[r][c].type = (color === 'white') ? chosenPieceType.toUpperCase() : chosenPieceType.toLowerCase();
                
                const finalMoveNotation = originalMoveNotation + "=" + chosenPieceType.toUpperCase(); 

                gameState.awaitingPromotion = null;
                promotionChoicesDiv.style.display = 'none';
                updateCancelButtonVisibility(); 
                
                renderBoard(); 
                endTurn(finalMoveNotation, movingPiece, fromR, r, fromC, c);
            }
        });

        document.getElementById('download-game-button').addEventListener('click', () => { 
            if (gameState.awaitingPromotion) {
                alert("Cannot download game while awaiting pawn promotion.");
                return;
            }
            // Ensure the saved state reflects the true latest state, not a historical view
            const stateToSave = deepCopyFullState(gameState);
            stateToSave.currentHistoryViewIndex = stateToSave.history.length - 1;
            loadStateFromHistory(stateToSave.currentHistoryViewIndex, false); // Temporarily load latest state into gameState for saving
            stateToSave.useStandardPieces = useStandardPieces; 
            
            const serializedState = JSON.stringify(stateToSave);

            const clonedDocument = document.cloneNode(true);
            
            let existingSavedScriptInClone = clonedDocument.getElementById('savedGameStateData');
            if (existingSavedScriptInClone) {
                existingSavedScriptInClone.textContent = serializedState; 
            } else { 
                const scriptTag = clonedDocument.createElement('script');
                scriptTag.id = 'savedGameStateData';
                scriptTag.type = 'application/json'; 
                scriptTag.textContent = serializedState;
                clonedDocument.head.appendChild(scriptTag);
            }

            const fullHtmlContent = '<!DOCTYPE html>\n' + clonedDocument.documentElement.outerHTML;
            const blob = new Blob([fullHtmlContent], { type: 'text/html;charset=utf-8' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            
            let filename = "Spell_chess.html"; 
            if (stateToSave.moveLog.length > 0) {
                const lastFullTurnEntryIndex = stateToSave.moveLog.length - 1;
                let turnNumberForFile = stateToSave.moveLog[lastFullTurnEntryIndex].turn;
                let whiteMoveForFile = "";
                let blackMoveForFile = "";

                for(let i = lastFullTurnEntryIndex; i >=0; i--){
                    if(stateToSave.moveLog[i].turn === turnNumberForFile && stateToSave.moveLog[i].player === 'white'){
                        whiteMoveForFile = stateToSave.moveLog[i].notation.replace(/[#+=\s@]/g, '');
                        break;
                    }
                     if(stateToSave.moveLog[i].turn < turnNumberForFile) break;
                }
                for(let i = lastFullTurnEntryIndex; i >=0; i--){
                     if(stateToSave.moveLog[i].turn === turnNumberForFile && stateToSave.moveLog[i].player === 'black'){
                        blackMoveForFile = stateToSave.moveLog[i].notation.replace(/[#+=\s@]/g, '');
                        break;
                    }
                    if(stateToSave.moveLog[i].turn < turnNumberForFile) break;
                }
                
                filename = `${turnNumberForFile}`;
                if (whiteMoveForFile) {
                    filename += whiteMoveForFile;
                }
                if (blackMoveForFile) {
                     filename += (whiteMoveForFile ? "_" : "") + blackMoveForFile;
                }
                filename += ".html";
            }
            link.download = filename;

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);

             // Restore the view to what the user was looking at
            loadStateFromHistory(gameState.currentHistoryViewIndex, true);
        });

        document.getElementById('download-gif-button').addEventListener('click', async () => {
            if (gameState.awaitingPromotion) {
                alert("Cannot generate GIF frames while awaiting pawn promotion.");
                return;
            }
            if (gameState.history.length <= 1 && gameState.plyCount === 0) { 
                alert("No moves made to generate GIF frames.");
                return;
            }

            updateStatus("Preparing to download GIF frames... Please allow multiple downloads if prompted.");
            document.getElementById('download-gif-button').disabled = true;
            document.querySelectorAll('.controls button:not(#download-gif-button)').forEach(btn => btn.disabled = true);
            
            window.open('https://ezgif.com/maker', '_blank');

            const originalHistoryViewIndex = gameState.currentHistoryViewIndex;
            
            try {
                for (let i = 0; i < gameState.history.length; i++) {
                    loadStateFromHistory(i, false); // Load state without full UI update
                    applyPieceStyle();
                    
                    updateStatus(`Downloading frame ${i + 1} of ${gameState.history.length}...`);
                    await new Promise(resolve => setTimeout(resolve, 50)); 

                    const canvas = await html2canvas(chessboardDiv, {
                        allowTaint: true, 
                        useCORS: true, 
                        logging: false,
                        width: chessboardDiv.offsetWidth,
                        height: chessboardDiv.offsetHeight,
                        backgroundColor: null 
                    });
                    
                    const link = document.createElement('a');
                    link.download = `spell_chess_frame_${String(i).padStart(3, '0')}.png`;
                    link.href = canvas.toDataURL('image/png');
                    document.body.appendChild(link); 
                    link.click();
                    document.body.removeChild(link); 
                    await new Promise(resolve => setTimeout(resolve, 250)); 
                }
                updateStatus("All GIF frames downloaded. You can assemble them at ezgif.com.");

            } catch (error) {
                console.error("Error during GIF frame download process:", error);
                updateStatus("GIF frame download failed.");
            } finally {
                // Restore the game to its original viewing state
                loadStateFromHistory(originalHistoryViewIndex, true); 
                document.getElementById('download-gif-button').disabled = false;
            }
        });

        function renderBoard() {
            chessboardDiv.innerHTML = '';
            if (!useStandardPieces) {
                chessboardDiv.classList.add('colored-pieces');
            } else {
                chessboardDiv.classList.remove('colored-pieces');
            }
            
            const validMovesForSelected = gameState.selectedPiece ? getValidMovesForPiece(gameState.selectedPiece.r, gameState.selectedPiece.c) : [];

            gameState.board.forEach((row, r_idx) => {
                row.forEach((piece, c_idx) => {
                    const square = document.createElement('div');
                    square.classList.add('square');
                    square.classList.add((r_idx + c_idx) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.r = r_idx;
                    square.dataset.c = c_idx;

                    square.classList.remove('active-freeze-zone', 'jumpable-on-square',
                                            'freeze-outline-top', 'freeze-outline-bottom',
                                            'freeze-outline-left', 'freeze-outline-right');
                    
                    if (isSquareUnderActiveFreeze(r_idx, c_idx, gameState.activeSpells, gameState.plyCount)) {
                        square.classList.add('active-freeze-zone');
                        const freezeEmojiSpan = document.createElement('span');
                        freezeEmojiSpan.classList.add('square-freeze-emoji');
                        freezeEmojiSpan.textContent = '‚ùÑÔ∏è';
                        square.appendChild(freezeEmojiSpan);
                    } else if (piece && piece.isJumpable) {
                        square.classList.add('jumpable-on-square');
                    }
                     gameState.activeSpells.forEach(spell => {
                        if (spell.type === 'freeze' && gameState.plyCount < spell.expiresAtPly) {
                            const spellCenterR = spell.targetSquare.r;
                            const spellCenterC = spell.targetSquare.c;
                            const minEffectR = Math.max(0, spellCenterR - 1);
                            const maxEffectR = Math.min(7, spellCenterR + 1);
                            const minEffectC = Math.max(0, spellCenterC - 1);
                            const maxEffectC = Math.min(7, spellCenterC + 1);
                            if (r_idx >= minEffectR && r_idx <= maxEffectR && c_idx >= minEffectC && c_idx <= maxEffectC) {
                                if (r_idx === minEffectR) square.classList.add('freeze-outline-top');
                                if (r_idx === maxEffectR) square.classList.add('freeze-outline-bottom');
                                if (c_idx === minEffectC) square.classList.add('freeze-outline-left');
                                if (c_idx === maxEffectC) square.classList.add('freeze-outline-right');
                            }
                        }
                    });


                    if (piece) {
                        const pieceSpan = document.createElement('span');
                        pieceSpan.classList.add('piece');
                        
                        let displayPieceType = piece.type;
                        if (!useStandardPieces && piece.color === 'white') {
                            displayPieceType = piece.type.toLowerCase(); 
                            pieceSpan.classList.add('white-piece-alternative'); 
                        } else { 
                            pieceSpan.classList.remove('white-piece-alternative');
                        }

                        pieceSpan.textContent = PIECES[displayPieceType];
                        pieceSpan.dataset.pieceId = piece.id;
                        square.appendChild(pieceSpan);
                    }

                    if (gameState.selectedPiece && gameState.selectedPiece.r === r_idx && gameState.selectedPiece.c === c_idx) {
                        square.classList.add('selected');
                    }

                    if (validMovesForSelected.some(move => move.toR === r_idx && move.toC === c_idx)) {
                       square.classList.add('valid-move-hint');
                    }

                    square.addEventListener('click', () => onSquareClick(r_idx, c_idx));
                    chessboardDiv.appendChild(square);
                });
            });
        }

        function isSquareUnderActiveFreeze(sqR, sqC, activeSpells, currentPly) {
            for (const spell of activeSpells) {
                if (spell.type === 'freeze' && currentPly < spell.expiresAtPly) {
                    const centerR = spell.targetSquare.r;
                    const centerC = spell.targetSquare.c;
                    if (Math.abs(sqR - centerR) <= 1 && Math.abs(sqC - centerC) <= 1) {
                        if (sqR >= Math.max(0, centerR -1) && sqR <= Math.min(7, centerR + 1) &&
                            sqC >= Math.max(0, centerC -1) && sqC <= Math.min(7, centerC + 1)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function onSquareClick(r_clicked, c_clicked) {
            const isViewingLatest = gameState.currentHistoryViewIndex === gameState.history.length - 1;
            if (!isViewingLatest && !gameState.isGameOver) {
                updateStatus("You are viewing a past move. Click '>' to return to the present or make a new move to create a new game line.");
            }

            if (gameState.isGameOver || gameState.awaitingPromotion) { 
                if (gameState.awaitingPromotion) updateStatus("Choose promotion piece.");
                else if (!isViewingLatest) { /* allow clicks on board when game is over but not on latest move */ }
                else {
                    updateStatus("Game is over. Please reset to play again.");
                    return;
                }
            }

            const pieceAtClickedSquare = gameState.board[r_clicked][c_clicked];

            if (gameState.spellMode) {
                handleSpellTargeting(r_clicked, c_clicked);
                return;
            }

            if (gameState.selectedPiece) {
                if (gameState.selectedPiece.r === r_clicked && gameState.selectedPiece.c === c_clicked) {
                    gameState.selectedPiece = null;
                    renderBoard();
                    updateCancelButtonVisibility(); 
                    return;
                }

                const { r: fromR, c: fromC, piece: movingPiece } = gameState.selectedPiece;

                if (isValidMove(fromR, fromC, r_clicked, c_clicked, gameState.board, gameState.currentPlayer, gameState.enPassantTarget, gameState.castlingRights, gameState.activeSpells, gameState.plyCount)) {
                    let capturedPiece = gameState.board[r_clicked][c_clicked];
                    let moveNotation = generateMoveNotation(gameState, movingPiece, fromR, fromC, r_clicked, c_clicked, capturedPiece);
                    let isEnPassantCapture = false;
                    let isCastle = false;

                    if (movingPiece.type.toLowerCase() === 'k' && Math.abs(fromC - c_clicked) === 2) {
                        isCastle = true;
                        moveNotation = c_clicked > fromC ? "O-O" : "O-O-O";
                        
                        const rookFromC = c_clicked > fromC ? 7 : 0;
                        const rookToC = c_clicked > fromC ? c_clicked - 1 : c_clicked + 1;
                        const rook = gameState.board[fromR][rookFromC];
                        if (rook) {
                            gameState.board[fromR][rookToC] = rook;
                            gameState.board[fromR][rookFromC] = null;
                            rook.hasMoved = true;
                        }
                    } else if (movingPiece.type.toLowerCase() === 'p' &&
                        Math.abs(fromC - c_clicked) === 1 &&
                        !gameState.board[r_clicked][c_clicked] &&
                        gameState.enPassantTarget &&
                        r_clicked === gameState.enPassantTarget.r &&
                        c_clicked === gameState.enPassantTarget.c) {
                        isEnPassantCapture = true;
                        const epCapturedPawnActualR = fromR;
                        const epCapturedPawnActualC = c_clicked;
                        capturedPiece = gameState.board[epCapturedPawnActualR][epCapturedPawnActualC];
                        gameState.board[epCapturedPawnActualR][epCapturedPawnActualC] = null;
                        moveNotation = generateMoveNotation(gameState, movingPiece, fromR, fromC, r_clicked, c_clicked, capturedPiece, true);
                    }
                    
                    // General piece movement logic
                    gameState.board[r_clicked][c_clicked] = movingPiece;
                    gameState.board[fromR][fromC] = null;
                    movingPiece.hasMoved = true;

                    // Update castling rights
                    if (movingPiece.type.toLowerCase() === 'k') {
                        if (movingPiece.color === 'white') {
                            gameState.castlingRights.white.K = false;
                            gameState.castlingRights.white.Q = false;
                        } else {
                            gameState.castlingRights.black.k = false;
                            gameState.castlingRights.black.q = false;
                        }
                    } else if (movingPiece.type.toLowerCase() === 'r') {
                        if (movingPiece.color === 'white') {
                            if (fromR === 7 && fromC === 0) gameState.castlingRights.white.Q = false;
                            if (fromR === 7 && fromC === 7) gameState.castlingRights.white.K = false;
                        } else {
                            if (fromR === 0 && fromC === 0) gameState.castlingRights.black.q = false;
                            if (fromR === 0 && fromC === 7) gameState.castlingRights.black.k = false;
                        }
                    }

                    gameState.selectedPiece = null; 

                    if (!isCastle && movingPiece.type.toLowerCase() === 'p' &&
                        ((movingPiece.color === 'white' && r_clicked === 0) || (movingPiece.color === 'black' && r_clicked === 7))) {
                        
                        gameState.awaitingPromotion = {
                            r: r_clicked,
                            c: c_clicked,
                            color: movingPiece.color,
                            originalMoveNotation: moveNotation,
                            movingPiece: gameState.board[r_clicked][c_clicked], 
                            fromR: fromR, 
                            fromC: fromC  
                        };
                        promotionChoicesDiv.style.display = 'flex'; 
                        cancelButton.style.display = 'none'; 
                        updateStatus(`Choose promotion for pawn at ${String.fromCharCode(97 + c_clicked)}${8 - r_clicked}.`);
                        renderBoard(); 
                        return; 
                    }
                    
                    const pieceToEndTurnWith = gameState.board[r_clicked][c_clicked] || movingPiece; 
                    endTurn(moveNotation, pieceToEndTurnWith, fromR, r_clicked, fromC, c_clicked);
                } else if (pieceAtClickedSquare && pieceAtClickedSquare.color === gameState.currentPlayer) {
                    let effectivelyFrozenNewSelection = pieceAtClickedSquare.isFrozen || isSquareUnderActiveFreeze(r_clicked, c_clicked, gameState.activeSpells, gameState.plyCount);
                    if (effectivelyFrozenNewSelection) {
                        updateStatus("This piece is frozen or on a frozen square and cannot move.");
                        return; 
                    }
                    gameState.selectedPiece = { r: r_clicked, c: c_clicked, piece: pieceAtClickedSquare };
                    renderBoard();
                } else { 
                    updateStatus("Invalid move or empty square. Try again.");
                    gameState.selectedPiece = null; 
                    renderBoard();
                }
            } else { 
                if (pieceAtClickedSquare && pieceAtClickedSquare.color === gameState.currentPlayer) {
                    let effectivelyFrozenInitialSelection = pieceAtClickedSquare.isFrozen || isSquareUnderActiveFreeze(r_clicked, c_clicked, gameState.activeSpells, gameState.plyCount);
                    if (effectivelyFrozenInitialSelection) {
                        updateStatus("This piece is frozen or on a frozen square and cannot move.");
                        return;
                    }
                    gameState.selectedPiece = { r: r_clicked, c: c_clicked, piece: pieceAtClickedSquare };
                    renderBoard();
                }
            }
            updateCancelButtonVisibility(); 
        }

        function isPathClear(fromR, fromC, toR, toC, board) {
            const dr = Math.sign(toR - fromR);
            const dc = Math.sign(toC - fromC);
            let r = fromR + dr;
            let c = fromC + dc;

            while (r !== toR || c !== toC) {
                if (r < 0 || r >= 8 || c < 0 || c >= 8) return false; 
                const pieceOnPath = board[r][c];
                if (pieceOnPath && !pieceOnPath.isJumpable) { 
                    return false; 
                }
                r += dr;
                c += dc;
            }
            return true;
        }

        function isSquareAttacked(targetR, targetC, attackerColor, board, enPassantTarget, activeSpells, currentPly) {
            for (let r_attacker = 0; r_attacker < 8; r_attacker++) { 
                for (let c_attacker = 0; c_attacker < 8; c_attacker++) {
                    const piece = board[r_attacker][c_attacker];
                    if (piece && piece.color === attackerColor) {
                        let effectivelyFrozenAttacker = piece.isFrozen || isSquareUnderActiveFreeze(r_attacker, c_attacker, activeSpells, currentPly);
                        if (effectivelyFrozenAttacker && piece.type.toLowerCase() !== 'k') continue; 


                        const pieceType = piece.type.toLowerCase();
                        if (pieceType === 'p') {
                            const attackDR = (attackerColor === 'white') ? -1 : 1; 
                            if (r_attacker + attackDR === targetR && Math.abs(c_attacker - targetC) === 1) return true;
                        } else if (pieceType === 'n') {
                            const drAbs = Math.abs(targetR - r_attacker);
                            const dcAbs = Math.abs(targetC - c_attacker);
                            if ((drAbs === 2 && dcAbs === 1) || (drAbs === 1 && dcAbs === 2)) return true;
                        } else if (pieceType === 'r' || pieceType === 'q') { 
                            if ((r_attacker === targetR || c_attacker === targetC) && isPathClear(r_attacker, c_attacker, targetR, targetC, board)) {
                                return true;
                            }
                        } 
                        if (pieceType === 'b' || pieceType === 'q') { 
                             if (Math.abs(targetR - r_attacker) === Math.abs(targetC - c_attacker) && isPathClear(r_attacker, c_attacker, targetR, targetC, board)) {
                                return true;
                            }
                        }
                        if (pieceType === 'k') { 
                            if (Math.abs(targetR - r_attacker) <= 1 && Math.abs(targetC - c_attacker) <= 1) return true;
                        }
                    }
                }
            }
            return false;
        }

        function checkCastleConditions(kingFromR, kingFromC, kingToR, kingToC, board, player, castlingRights, activeSpells, currentPly, enPassantTarget) {
            const opponentColor = player === 'white' ? 'black' : 'white';
            const king = board[kingFromR][kingFromC];

            if (!king || king.hasMoved) return false; 

            if (isKingInCheck(player, board, enPassantTarget, activeSpells, currentPly)) return false;

            const isKingside = kingToC > kingFromC;

            if (isKingside) {
                if (player === 'white' && !castlingRights.white.K) return false;
                if (player === 'black' && !castlingRights.black.k) return false;
                const rook = board[kingFromR][7];
                if (!rook || rook.type.toLowerCase() !== 'r' || rook.hasMoved) return false;


                if (board[kingFromR][kingFromC + 1] || board[kingFromR][kingFromC + 2]) return false;
                
                if (isSquareAttacked(kingFromR, kingFromC + 1, opponentColor, board, enPassantTarget, activeSpells, currentPly)) return false;
                if (isSquareAttacked(kingFromR, kingFromC + 2, opponentColor, board, enPassantTarget, activeSpells, currentPly)) return false;
            } else { // Queenside
                if (player === 'white' && !castlingRights.white.Q) return false;
                if (player === 'black' && !castlingRights.black.q) return false;
                const rook = board[kingFromR][0];
                if (!rook || rook.type.toLowerCase() !== 'r' || rook.hasMoved) return false;

                if (board[kingFromR][kingFromC - 1] || board[kingFromR][kingFromC - 2] || board[kingFromR][kingFromC - 3]) return false;
                
                if (isSquareAttacked(kingFromR, kingFromC - 1, opponentColor, board, enPassantTarget, activeSpells, currentPly)) return false;
                if (isSquareAttacked(kingFromR, kingFromC - 2, opponentColor, board, enPassantTarget, activeSpells, currentPly)) return false;
            }
            return true;
        }

        function isValidMove(fromR, fromC, toR, toC, board, currentPlayer, currentEnPassantTarget, currentCastlingRights, activeSpells, currentPly) {
            const movingPiece = board[fromR][fromC];
            if (!movingPiece || movingPiece.color !== currentPlayer) return false;

            let effectivelyFrozenMovingPiece = movingPiece.isFrozen || isSquareUnderActiveFreeze(fromR, fromC, activeSpells, currentPly);
            if (effectivelyFrozenMovingPiece) return false;

            if (fromR === toR && fromC === toC) return false;

            const targetPiece = board[toR][toC];
            if (targetPiece && targetPiece.color === movingPiece.color) return false;

            const pieceType = movingPiece.type.toLowerCase();

            if (pieceType === 'k' && Math.abs(toC - fromC) === 2 && fromR === toR) {
                return checkCastleConditions(fromR, fromC, toR, toC, board, currentPlayer, currentCastlingRights, activeSpells, currentPly, currentEnPassantTarget);
            }

            let isValidSpecificMove = false;
            switch (pieceType) {
                case 'p':
                    const colorMultiplier = (movingPiece.color === 'white') ? -1 : 1;
                    if (toR === fromR + colorMultiplier && toC === fromC && !targetPiece) {
                        isValidSpecificMove = true;
                    } else if (toR === fromR + 2 * colorMultiplier && toC === fromC && !movingPiece.hasMoved && !targetPiece && !board[fromR + colorMultiplier][fromC]) {
                        isValidSpecificMove = true;
                    } else if (toR === fromR + colorMultiplier && Math.abs(toC - fromC) === 1 && targetPiece && targetPiece.color !== movingPiece.color) {
                        isValidSpecificMove = true;
                    } else if (toR === fromR + colorMultiplier && Math.abs(toC - fromC) === 1 && !targetPiece &&
                               currentEnPassantTarget && toR === currentEnPassantTarget.r && toC === currentEnPassantTarget.c) {
                        const epCapturedPawnActualR = fromR;
                        const epCapturedPawnActualC = toC;
                        const pawnToCapture = board[epCapturedPawnActualR]?.[epCapturedPawnActualC];
                        if (pawnToCapture && pawnToCapture.type.toLowerCase() === 'p' && pawnToCapture.color !== movingPiece.color) {
                             isValidSpecificMove = true;
                        }
                    }
                    break;
                case 'n':
                    const drN = Math.abs(toR - fromR);
                    const dcN = Math.abs(toC - fromC);
                    if ((drN === 2 && dcN === 1) || (drN === 1 && dcN === 2)) {
                        isValidSpecificMove = true;
                    }
                    break;
                case 'b':
                    if (Math.abs(toR - fromR) === Math.abs(toC - fromC)) {
                        if (isPathClear(fromR, fromC, toR, toC, board)) isValidSpecificMove = true;
                    }
                    break;
                case 'r':
                    if (fromR === toR || fromC === toC) {
                        if (isPathClear(fromR, fromC, toR, toC, board)) isValidSpecificMove = true;
                    }
                    break;
                case 'q':
                    if ((fromR === toR || fromC === toC) || (Math.abs(toR - fromR) === Math.abs(toC - fromC))) {
                        if (isPathClear(fromR, fromC, toR, toC, board)) isValidSpecificMove = true;
                    }
                    break;
                case 'k':
                    const drK = Math.abs(toR - fromR);
                    const dcK = Math.abs(toC - fromC);
                    if (drK <= 1 && dcK <= 1) {
                        isValidSpecificMove = true;
                    }
                    break;
            }

            if (!isValidSpecificMove) return false;

            // NEW RULE: If the move is a king capture, it's always legal regardless of check.
            if (targetPiece && targetPiece.type.toLowerCase() === 'k') {
                return true;
            }

            // Standard check validation for all other moves.
            const tempBoard = board.map(row => row.map(p => p ? {...p} : null));
            const pieceToMoveCopy = tempBoard[fromR][fromC];
            tempBoard[toR][toC] = pieceToMoveCopy;
            tempBoard[fromR][fromC] = null;

            if (pieceType === 'p' && currentEnPassantTarget && toR === currentEnPassantTarget.r && toC === currentEnPassantTarget.c && !targetPiece) {
                 const epCapturedPawnActualR = fromR;
                 const epCapturedPawnActualC = toC;
                 if (tempBoard[epCapturedPawnActualR] && tempBoard[epCapturedPawnActualR][epCapturedPawnActualC]) {
                    tempBoard[epCapturedPawnActualR][epCapturedPawnActualC] = null;
                 }
            }

            let kingPos;
            const currentPlayerKingType = currentPlayer === 'white' ? 'K' : 'k';
            for (let r_king = 0; r_king < 8; r_king++) {
                for (let c_king = 0; c_king < 8; c_king++) {
                    if (tempBoard[r_king][c_king] && tempBoard[r_king][c_king].type === currentPlayerKingType) {
                        kingPos = { r: r_king, c: c_king };
                        break;
                    }
                }
                if (kingPos) break;
            }

            if (!kingPos) return true; // Should not happen in a valid game.

            const opponentColor = currentPlayer === 'white' ? 'black' : 'white';
            if (isSquareAttacked(kingPos.r, kingPos.c, opponentColor, tempBoard, null, activeSpells, currentPly )) {
                return false;
            }

            return true;
        }
        
        function getValidMovesForPiece(r_piece, c_piece) { 
            const refinedValidMoves = [];
            for (let tr = 0; tr < 8; tr++) {
                for (let tc = 0; tc < 8; tc++) {
                     if (isValidMove(r_piece, c_piece, tr, tc, gameState.board, gameState.currentPlayer, gameState.enPassantTarget, gameState.castlingRights, gameState.activeSpells, gameState.plyCount)) {
                        refinedValidMoves.push({ fromR: r_piece, fromC: c_piece, toR: tr, toC: tc });
                    }
                }
            }
            return refinedValidMoves;
        }

        function isKingInCheck(kingColor, board, enPassantTarget, activeSpells, currentPly) {
            let kingPos = null;
            const kingType = (kingColor === 'white') ? 'K' : 'k';
            const attackerColor = (kingColor === 'white') ? 'black' : 'white';

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const pieceOnSquare = board[r][c];
                    if (pieceOnSquare && pieceOnSquare.type === kingType) {
                        kingPos = { r, c };
                        break;
                    }
                }
                if (kingPos) break;
            }

            if (!kingPos) return false; 
            
            return isSquareAttacked(kingPos.r, kingPos.c, attackerColor, board, enPassantTarget, activeSpells, currentPly);
        }

        function hasLegalMoves(playerColor, board, enPassantTarget, currentCastlingRights, activeSpells, currentPly, playerSpellsState, playerTurnNumberForCooldown) {
            // 1. Check for standard legal moves.
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece.color === playerColor) {
                        let isPieceEffectivelyFrozen = piece.isFrozen || isSquareUnderActiveFreeze(r, c, activeSpells, currentPly);
                        if (isPieceEffectivelyFrozen) continue;

                        for (let toR = 0; toR < 8; toR++) {
                            for (let toC = 0; toC < 8; toC++) {
                                if (isValidMove(r, c, toR, toC, board, playerColor, enPassantTarget, currentCastlingRights, activeSpells, currentPly)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }

            // If we are here, no standard moves save the player. Now check if spells can save them.
            // This is only relevant if the player is currently in check, which is determined by the calling function.

            // 2. Check if casting a JUMP spell can create a legal move.
            const canCastJump = playerSpellsState.jump > 0 && (playerSpellsState.jumpLastUsedTurn === 0 || playerTurnNumberForCooldown >= playerSpellsState.jumpLastUsedTurn + 3);

            if (canCastJump && isKingInCheck(playerColor, board, enPassantTarget, activeSpells, currentPly)) {
                // Iterate through every piece on the board to potentially make it jumpable
                for (let jump_r = 0; jump_r < 8; jump_r++) {
                    for (let jump_c = 0; jump_c < 8; jump_c++) {
                        if (board[jump_r][jump_c]) {
                            // Create a temporary board where this piece is jumpable
                            const tempBoardWithJump = JSON.parse(JSON.stringify(board));
                            tempBoardWithJump[jump_r][jump_c].isJumpable = true;

                            // Now, with the jumpable piece active, check if any of the player's pieces has a legal move
                            for (let move_r = 0; move_r < 8; move_r++) {
                                for (let move_c = 0; move_c < 8; move_c++) {
                                    const movingPiece = tempBoardWithJump[move_r][move_c];
                                    if (movingPiece && movingPiece.color === playerColor) {
                                        let isPieceEffectivelyFrozen = movingPiece.isFrozen || isSquareUnderActiveFreeze(move_r, move_c, activeSpells, currentPly);
                                        if (isPieceEffectivelyFrozen) continue;

                                        // Check all possible destination squares for this piece
                                        for (let to_r = 0; to_r < 8; to_r++) {
                                            for (let to_c = 0; to_c < 8; to_c++) {
                                                // isValidMove will check if the move is legal on the temp board AND if it gets the king out of check
                                                if (isValidMove(move_r, move_c, to_r, to_c, tempBoardWithJump, playerColor, enPassantTarget, currentCastlingRights, activeSpells, currentPly)) {
                                                    return true; // Found a saving move via Jump spell
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // 3. Check if casting a FREEZE spell can create a legal move.
            const canCastFreeze = playerSpellsState.freeze > 0 && (playerSpellsState.freezeLastUsedTurn === 0 || playerTurnNumberForCooldown >= playerSpellsState.freezeLastUsedTurn + 3);

            if (canCastFreeze && isKingInCheck(playerColor, board, enPassantTarget, activeSpells, currentPly)) {
                for (let fr = 0; fr < 8; fr++) {
                    for (let fc = 0; fc < 8; fc++) {
                        const tempActiveSpells = JSON.parse(JSON.stringify(activeSpells));
                        tempActiveSpells.push({
                            type: 'freeze',
                            targetSquare: { r: fr, c: fc },
                            expiresAtPly: currentPly + 2
                        });

                        // Check if this freeze gets the king out of check (by freezing the attacker)
                        if (!isKingInCheck(playerColor, board, enPassantTarget, tempActiveSpells, currentPly + 1)) {
                            // If the king is no longer in check, we just need to find ANY legal move
                            for (let pr = 0; pr < 8; pr++) {
                                for (let pc = 0; pc < 8; pc++) {
                                    const p = board[pr][pc];
                                    if (p && p.color === playerColor) {
                                        let effectivelyFrozenByTempSpells = p.isFrozen || isSquareUnderActiveFreeze(pr, pc, tempActiveSpells, currentPly + 1);
                                        if (!effectivelyFrozenByTempSpells) {
                                            for (let ptoR = 0; ptoR < 8; ptoR++) {
                                                for (let ptoC = 0; ptoC < 8; ptoC++) {
                                                    // Note: We use the original board here, but check validity against the new spell list
                                                    if (isValidMove(pr, pc, ptoR, ptoC, board, playerColor, enPassantTarget, currentCastlingRights, tempActiveSpells, currentPly + 1)) {
                                                        return true; // Found a legal move after being saved by a freeze spell
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }
        
        function generateMoveNotation(state, piece, fromR, fromC, toR, toC, capturedPiece, isEnPassant = false) {
            const pieceTypeUpper = piece.type.toUpperCase();
            
            // For pawn moves, notation is simpler
            if (pieceTypeUpper === 'P') {
                let notation = "";
                if (capturedPiece) {
                    notation += String.fromCharCode(97 + fromC) + 'x';
                }
                notation += String.fromCharCode(97 + toC) + (8 - toR);
                 if (isEnPassant) {
                    notation += " e.p.";
                }
                return notation;
            }

            let notation = pieceTypeUpper;

            // Find other pieces of the same type that can also move to the target square
            const competitors = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (r === fromR && c === fromC) continue;
                    const p = state.board[r][c];
                    if (p && p.color === piece.color && p.type === piece.type) {
                         if (isValidMove(r, c, toR, toC, state.board, state.currentPlayer, state.enPassantTarget, state.castlingRights, state.activeSpells, state.plyCount)) {
                             competitors.push({r,c});
                         }
                    }
                }
            }

            // If there are competitors, add disambiguation
            if (competitors.length > 0) {
                const fromFile = String.fromCharCode(97 + fromC);
                const fromRank = (8 - fromR).toString();

                const sameFileCompetitors = competitors.filter(comp => comp.c === fromC);
                const sameRankCompetitors = competitors.filter(comp => comp.r === fromR);
                
                if(sameFileCompetitors.length > 0 && sameRankCompetitors.length > 0) {
                     notation += fromFile + fromRank; // Both file and rank are needed
                }
                else if (sameFileCompetitors.length > 0) {
                    notation += fromRank; // Rooks on same file, use rank
                } else {
                    notation += fromFile; // Default to file
                }
            }
            
            if (capturedPiece) {
                notation += 'x';
            }
            
            notation += String.fromCharCode(97 + toC) + (8 - toR);
            
            return notation;
        }

        function handleSpellTargeting(r_target, c_target) { 
            const targetPiece = gameState.board[r_target][c_target];
            let spellApplied = false;
            let spellNotation = "";
            const spellCaster = gameState.spellCaster; 
            const playerSpells = gameState.spells[spellCaster];
            const currentCastingGameTurn = gameState.gameTurnNumber; 

            if (gameState.spellMode === 'jump') {
                if (targetPiece) {
                    playerSpells.jump--;
                    playerSpells.jumpLastUsedTurn = currentCastingGameTurn; 
                    
                    gameState.activeSpells.push({
                        type: 'jump',
                        targetId: targetPiece.id,
                        expiresAtPly: gameState.plyCount + 2 
                    });
                    targetPiece.isJumpable = true; 
                    spellApplied = true;
                    spellNotation = `jump@${String.fromCharCode(97 + c_target)}${8 - r_target}`;
                    updateStatus(`${spellCaster.charAt(0).toUpperCase() + spellCaster.slice(1)} cast Jump on ${PIECES[targetPiece.type]} at ${String.fromCharCode(97 + c_target)}${8 - r_target}. Make your move.`);
                } else {
                    updateStatus("Jump spell must target a piece. Select a piece to Jump or Cancel.");
                    renderBoard(); 
                    updateCancelButtonVisibility(); 
                    return; 
                }
            } else if (gameState.spellMode === 'freeze') {
                playerSpells.freeze--;
                playerSpells.freezeLastUsedTurn = currentCastingGameTurn;

                const affectedPieceIds = [];
                const freezeCenterR = r_target;
                const freezeCenterC = c_target;
                
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        const nr = freezeCenterR + dr; 
                        const nc = freezeCenterC + dc; 
                        if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) { 
                            const pieceToFreeze = gameState.board[nr][nc];
                            if (pieceToFreeze) {
                                affectedPieceIds.push(pieceToFreeze.id);
                            }
                        }
                    }
                }
                gameState.activeSpells.push({
                    type: 'freeze',
                    targetSquare: {r: freezeCenterR, c: freezeCenterC}, 
                    affectedPieceIds: affectedPieceIds, 
                    expiresAtPly: gameState.plyCount + 2 
                });
                spellApplied = true;
                spellNotation = `freeze@${String.fromCharCode(97 + c_target)}${8 - r_target}`;
                updateStatus(`${spellCaster.charAt(0).toUpperCase() + spellCaster.slice(1)} cast Freeze around ${String.fromCharCode(97 + c_target)}${8 - r_target}. Make your move.`);
            }

            if (spellApplied) {
                gameState.pendingSpellNotation = spellNotation;
                gameState.spellMode = null; 
            }
            renderBoard(); 
            updateSpellControls();
            updateCancelButtonVisibility();
        }

        function activateSpellMode(type) {
            if (gameState.selectedPiece) { 
                gameState.selectedPiece = null;
            }

            if (gameState.isGameOver || gameState.awaitingPromotion) return; 
            if (gameState.spellMode && gameState.spellMode !== type && gameState.spellCaster === gameState.currentPlayer) { 
                updateStatus("Another spell is already being targeted. Cancel it first.");
                return;
            }
             if (gameState.spellMode === type && gameState.spellCaster === gameState.currentPlayer) { 
                handleCancelAction(); 
                return;
            }
            if (gameState.pendingSpellNotation) { 
                updateStatus("You have already cast a spell this turn. Make your move or Cancel the cast spell.");
                return;
            }

            const playerSpells = gameState.spells[gameState.currentPlayer];
            const currentTurnForPlayerForCooldownCheck = gameState.gameTurnNumber;
            let count, lastUsedTurn, spellName;

            if (type === 'jump') {
                count = playerSpells.jump;
                lastUsedTurn = playerSpells.jumpLastUsedTurn;
                spellName = "Jump";
            } else { 
                count = playerSpells.freeze;
                lastUsedTurn = playerSpells.freezeLastUsedTurn;
                spellName = "Freeze";
            }

            if (count <= 0) {
                updateStatus(`No ${spellName} spells left.`);
                return;
            }
            if (lastUsedTurn > 0 && currentTurnForPlayerForCooldownCheck < lastUsedTurn + 3) { 
                updateStatus(`${spellName} spell is on cooldown. Available on game turn ${lastUsedTurn + 3}.`);
                return;
            }

            gameState.spellMode = type;
            gameState.spellCaster = gameState.currentPlayer;
            gameState.spellActivationState = { 
                type: type,
                originalLastUsedTurn: lastUsedTurn 
            };
            
            updateStatus(`${gameState.currentPlayer.charAt(0).toUpperCase() + gameState.currentPlayer.slice(1)} is casting ${spellName}. Select target on board or Cancel.`);
            cancelButton.textContent = "Cancel Spell";
            renderBoard(); 
            updateSpellControls(); 
            updateCancelButtonVisibility(); 
        }

        function handleCancelAction() {
            if (gameState.awaitingPromotion) {
                updateStatus("Choose a promotion piece.");
                return;
            }

            let playerDisplayTurn = "";
            const caster = gameState.spellCaster || gameState.currentPlayer; 
            if (caster) {
                 playerDisplayTurn = `${caster.charAt(0).toUpperCase() + caster.slice(1)}'s turn. `;
            }

            if (gameState.pendingSpellNotation) { 
                const playerToRefund = gameState.spellCaster; 
                const playerSpells = gameState.spells[playerToRefund];
                let cancelledSpellType = "";

                if (gameState.pendingSpellNotation.startsWith('jump@')) {
                    cancelledSpellType = 'jump';
                } else if (gameState.pendingSpellNotation.startsWith('freeze@')) {
                    cancelledSpellType = 'freeze';
                }

                let spellIndexToRemove = -1;
                for (let i = gameState.activeSpells.length - 1; i >= 0; i--) {
                    const spell = gameState.activeSpells[i];
                    if (spell.type === cancelledSpellType && spell.expiresAtPly === gameState.plyCount + 2) { 
                        spellIndexToRemove = i;
                        break;
                    }
                }
                
                if (spellIndexToRemove !== -1) {
                    const spellToCancel = gameState.activeSpells[spellIndexToRemove];
                    if (cancelledSpellType === 'jump') {
                        const jumpedPiece = findPieceById(spellToCancel.targetId);
                        if (jumpedPiece) jumpedPiece.isJumpable = false;
                        playerSpells.jump++;
                        if (gameState.spellActivationState && gameState.spellActivationState.type === 'jump') {
                            playerSpells.jumpLastUsedTurn = gameState.spellActivationState.originalLastUsedTurn;
                        }
                    } else if (cancelledSpellType === 'freeze') {
                        playerSpells.freeze++;
                        if (gameState.spellActivationState && gameState.spellActivationState.type === 'freeze') {
                            playerSpells.freezeLastUsedTurn = gameState.spellActivationState.originalLastUsedTurn;
                        }
                    }
                    gameState.activeSpells.splice(spellIndexToRemove, 1);
                }

                gameState.pendingSpellNotation = null;
                updateStatus(`${playerDisplayTurn}Spell cancelled.`);

            } else if (gameState.spellMode) { 
                updateStatus(`${playerDisplayTurn}Spell targeting cancelled.`);
            }

            gameState.spellMode = null;
            gameState.spellCaster = null;
            gameState.spellActivationState = null;
            
            updateAllUI();
        }
        
        function updateActiveSpells() {
            const stillActive = [];
            let boardNeedsRender = false;

            gameState.activeSpells.forEach(spell => {
                if (gameState.plyCount >= spell.expiresAtPly) { 
                    if (spell.type === 'freeze') {
                        // Visual effect of freeze zone is handled by renderBoard
                    } else if (spell.type === 'jump') {
                         const piece = findPieceById(spell.targetId);
                         if (piece) piece.isJumpable = false;
                    }
                    boardNeedsRender = true; 
                } else {
                    stillActive.push(spell); 
                }
            });
            gameState.activeSpells = stillActive; 
            
            if (boardNeedsRender) renderBoard(); 
        }

        function findPieceById(id) {
            for (let r_find = 0; r_find < 8; r_find++) { 
                for (let c_find = 0; c_find < 8; c_find++) {
                    if (gameState.board[r_find][c_find] && gameState.board[r_find][c_find].id === id) {
                        return gameState.board[r_find][c_find];
                    }
                }
            }
            return null;
        }

        function generateStateSignature(state) {
            const boardString = state.board.map(row => 
                row.map(p => {
                    if (!p) return ' ';
                    let char = p.type;
                    if(p.isJumpable) char += '*';
                    return char;
                }).join('')
            ).join('/');
            
            const spellCooldowns = `${state.spells.white.jumpLastUsedTurn},${state.spells.white.freezeLastUsedTurn},${state.spells.black.jumpLastUsedTurn},${state.spells.black.freezeLastUsedTurn}`;

            return `${boardString}|${state.currentPlayer}|${JSON.stringify(state.castlingRights)}|${JSON.stringify(state.enPassantTarget)}|${spellCooldowns}`;
        }
        
        function endTurn(moveNotation, movedPiece, fromR_param, toR_param, fromC_param, toC_param) {
            // If playing from a past move, truncate future history
            const isLatestMove = gameState.currentHistoryViewIndex === gameState.history.length - 1;
            if (!isLatestMove) {
                gameState.history = gameState.history.slice(0, gameState.currentHistoryViewIndex + 1);
                gameState.moveLog = gameState.moveLog.filter(log => log.plySnapshotIndex <= gameState.currentHistoryViewIndex);
                // Reset repetition counter for the new line of play
                gameState.repetitionCounter = {};
                gameState.history.forEach(hist => {
                    const sig = generateStateSignature(hist);
                    gameState.repetitionCounter[sig] = (gameState.repetitionCounter[sig] || 0) + 1;
                });
            }

            const playerWhoMoved = gameState.currentPlayer; 
            
            let compactActions = [];
            if(gameState.pendingSpellNotation) {
                const [spellType, targetAlg] = gameState.pendingSpellNotation.split('@');
                const coords = parseAlgebraicToCoords(targetAlg);
                const spellChar = spellType.charAt(0) === 'j' ? '.' : '~';
                compactActions.push(spellChar + coordToB64(coords.r, coords.c));
            }
            let compactMove = coordToB64(fromR_param, fromC_param) + coordToB64(toR_param, toC_param);
            if (moveNotation.includes('=')) {
                compactMove += moveNotation.slice(-1);
            }
            compactActions.push(compactMove);
            
            gameState.plyCount++; 
            updateActiveSpells(); 

            let gameEndMessage = "";
            let isCheck = false;
            let isCheckmate = false;
            let isDraw = false;

            const opponentColor = (playerWhoMoved === 'white') ? 'black' : 'white';
            const opponentKingStillExists = gameState.board.flat().some(p => p && p.type.toLowerCase() === 'k' && p.color === opponentColor);

            if (!opponentKingStillExists) {
                isCheckmate = true; 
                gameState.isGameOver = true;
                const winner = playerWhoMoved.charAt(0).toUpperCase() + playerWhoMoved.slice(1);
                gameEndMessage = `King captured! ${winner} wins!`;
            } else {
                const nextPlayerSpells = gameState.spells[opponentColor];
                // Determine the game turn number for the player under check.
                // If white just moved, it's still the same game turn for black.
                // If black just moved, the game turn will increment for white's move.
                const turnForCooldownCheck = (playerWhoMoved === 'black') 
                    ? gameState.gameTurnNumber + 1 
                    : gameState.gameTurnNumber;

                if (isKingInCheck(opponentColor, gameState.board, gameState.enPassantTarget, gameState.activeSpells, gameState.plyCount)) {
                    isCheck = true;
                    if (!hasLegalMoves(opponentColor, gameState.board, gameState.enPassantTarget, gameState.castlingRights, gameState.activeSpells, gameState.plyCount, nextPlayerSpells, turnForCooldownCheck)) {
                        isCheckmate = true;
                        gameState.isGameOver = true;
                        const winner = playerWhoMoved.charAt(0).toUpperCase() + playerWhoMoved.slice(1);
                        gameEndMessage = `Checkmate! ${winner} wins!`;
                    }
                } else { 
                    if (!hasLegalMoves(opponentColor, gameState.board, gameState.enPassantTarget, gameState.castlingRights, gameState.activeSpells, gameState.plyCount, nextPlayerSpells, turnForCooldownCheck)) {
                        isDraw = true;
                        gameState.isGameOver = true;
                        gameEndMessage = "Stalemate! Draw.";
                    }
                }
            }
            
            // Check for threefold repetition AFTER checking for checkmate/stalemate
            if (!gameState.isGameOver) {
                const signature = generateStateSignature(gameState);
                gameState.repetitionCounter[signature] = (gameState.repetitionCounter[signature] || 0) + 1;
                if (gameState.repetitionCounter[signature] >= 3) {
                    isDraw = true;
                    gameState.isGameOver = true;
                    gameEndMessage = "Draw by threefold repetition.";
                }
            }
            
            let finalMoveNotationWithSymbols = gameState.pendingSpellNotation ? gameState.pendingSpellNotation + " " + moveNotation : moveNotation;
            if (isCheckmate) {
                finalMoveNotationWithSymbols += "#";
            } else if (isCheck) {
                finalMoveNotationWithSymbols += "+";
            }
            gameState.pendingSpellNotation = null;

            let next_currentPlayer_state = gameState.currentPlayer; 
            let next_gameTurnNumber_state = gameState.gameTurnNumber;
            
            if (!gameState.isGameOver) {
                if (playerWhoMoved === 'white') { 
                    next_currentPlayer_state = 'black';
                } else { 
                    next_currentPlayer_state = 'white';
                    next_gameTurnNumber_state = gameState.gameTurnNumber + 1;
                }
            }

            gameState.moveLog.push({ 
                turn: gameState.gameTurnNumber, 
                player: playerWhoMoved, 
                notation: finalMoveNotationWithSymbols, 
                actions: compactActions, // Store compact actions for URL generation
                plySnapshotIndex: gameState.history.length
            });
            
            gameState.enPassantTarget = null; 
            if (movedPiece?.type.toLowerCase() === 'p' && Math.abs(fromR_param - toR_param) === 2) {
                gameState.enPassantTarget = { r: (fromR_param + toR_param) / 2, c: fromC_param };
            }
            gameState.spellActivationState = null; 
            gameState.spellCaster = null; 

            // Update current state for the next turn BEFORE snapshotting
            if (!gameState.isGameOver) {
                gameState.currentPlayer = next_currentPlayer_state;
                gameState.gameTurnNumber = next_gameTurnNumber_state;
            }

            // Snapshot the state AFTER the move and player switch
            const afterMoveState = deepCopyGameStateForSnapshot(gameState);
            afterMoveState.gameEndMessage = gameEndMessage;
            gameState.history.push(afterMoveState);
            gameState.currentHistoryViewIndex = gameState.history.length - 1;
            
            loadStateFromHistory(gameState.currentHistoryViewIndex, true);
        }
        
        function handleNotationClick(plySnapshotIndex) {
            if (gameState.awaitingPromotion) { 
                updateStatus("Please choose a promotion piece first.");
                return;
            }
            loadStateFromHistory(plySnapshotIndex, true);
        }
        
        function handleHistoryBack() {
            if (gameState.currentHistoryViewIndex > 0) {
                loadStateFromHistory(gameState.currentHistoryViewIndex - 1, true);
            }
        }

        function handleHistoryForward() {
            if (gameState.currentHistoryViewIndex < gameState.history.length - 1) {
                loadStateFromHistory(gameState.currentHistoryViewIndex + 1, true);
            }
        }

        function loadStateFromHistory(historyIndex, performFullUpdate) {
            if (historyIndex < 0 || historyIndex >= gameState.history.length) {
                console.error("Invalid historyIndex:", historyIndex);
                return;
            }
            
            gameState.currentHistoryViewIndex = historyIndex;
            const targetStateSnapshot = gameState.history[historyIndex];
            if (!targetStateSnapshot) {
                console.error("No state found in history for index:", historyIndex);
                return;
            }

            // Restore all keys from the snapshot
            const keysToRestore = [
                'board', 'currentPlayer', 'gameTurnNumber', 
                'plyCount', 'spells', 'activeSpells', 'enPassantTarget', 'castlingRights', 
                'isGameOver', 'gameEndMessage', 'awaitingPromotion', 'useStandardPieces'
            ];

            for (const key of keysToRestore) {
                 if (Object.prototype.hasOwnProperty.call(targetStateSnapshot, key)) {
                    // Deep copy objects to prevent mutation of history
                    if (typeof targetStateSnapshot[key] === 'object' && targetStateSnapshot[key] !== null) {
                        gameState[key] = JSON.parse(JSON.stringify(targetStateSnapshot[key]));
                    } else {
                        gameState[key] = targetStateSnapshot[key];
                    }
                }
            }
            
            // Reset transient states that are not part of history
            gameState.selectedPiece = null;
            gameState.spellMode = null;
            gameState.spellCaster = null;
            gameState.pendingSpellNotation = null;
            
            if (performFullUpdate) {
                useStandardPieces = gameState.useStandardPieces === undefined ? useStandardPieces : gameState.useStandardPieces;
                applyPieceStyle();
                updateAllUI();
            }
        }
        
        function updateAllUI() {
            updateStatusMessage();
            updateSpellControls();
            updateCancelButtonVisibility();
            updateNavigationButtons();
            updateNotationDisplay();
            renderBoard();
        }

        function updateStatusMessage() {
            const isViewingLatest = gameState.currentHistoryViewIndex === gameState.history.length - 1;

            if (gameState.isGameOver && isViewingLatest) {
                updateStatus(gameState.gameEndMessage || "Game over.");
            } else if (gameState.isGameOver && !isViewingLatest) {
                updateStatus(`Game over. Viewing move ${gameState.currentHistoryViewIndex}.`);
            } else if (gameState.awaitingPromotion) {
                 updateStatus(`Choose promotion for pawn at ${String.fromCharCode(97 + gameState.awaitingPromotion.c)}${8 - gameState.awaitingPromotion.r}.`);
            } else {
                let statusMsg = `${gameState.currentPlayer.charAt(0).toUpperCase() + gameState.currentPlayer.slice(1)}'s turn.`;
                if (gameState.board && gameState.board.length > 0 && 
                    isKingInCheck(gameState.currentPlayer, gameState.board, gameState.enPassantTarget, gameState.activeSpells, gameState.plyCount)) {
                    statusMsg += " Check!";
                }
                updateStatus(statusMsg);
            }
        }

        function updateNotationDisplay() {
            notationArea.innerHTML = ''; 
            let currentTurnDiv = null;
            let lastTurnNumberProcessed = 0;

            gameState.moveLog.forEach(moveEntry => {
                if (moveEntry.turn !== lastTurnNumberProcessed) {
                    if (currentTurnDiv) {
                        notationArea.appendChild(currentTurnDiv);
                    }
                    currentTurnDiv = document.createElement('div');
                    currentTurnDiv.classList.add('notation-line');
                    
                    const turnNumSpan = document.createElement('span');
                    turnNumSpan.classList.add('notation-turn-number');
                    turnNumSpan.textContent = `${moveEntry.turn}. `; 
                    currentTurnDiv.appendChild(turnNumSpan);
                    lastTurnNumberProcessed = moveEntry.turn;
                }

                const moveSpan = document.createElement('span');
                moveSpan.classList.add('notation-move');
                moveSpan.textContent = moveEntry.notation; 
                moveSpan.dataset.plySnapshotIndex = moveEntry.plySnapshotIndex;
                if (moveEntry.plySnapshotIndex === gameState.currentHistoryViewIndex) {
                    moveSpan.classList.add('current-move');
                }
                moveSpan.addEventListener('click', () => handleNotationClick(parseInt(moveSpan.dataset.plySnapshotIndex, 10)));
                
                if (currentTurnDiv) { 
                    currentTurnDiv.appendChild(moveSpan);
                    currentTurnDiv.appendChild(document.createTextNode(' ')); 
                }
            });

            if (currentTurnDiv) { 
                notationArea.appendChild(currentTurnDiv);
            }

            if (gameState.moveLog.length === 0) { 
                notationArea.innerHTML = ""; 
            }
            notationArea.scrollTop = notationArea.scrollHeight;
        }

        function updateStatus(message) {
            statusArea.textContent = message;
        }
        
        function updateCancelButtonVisibility() {
            if (gameState.awaitingPromotion) {
                cancelButton.style.display = 'none';
                promotionChoicesDiv.style.display = 'flex';
                return;
            }
            promotionChoicesDiv.style.display = 'none';

            if (!gameState.isGameOver && (gameState.spellMode || gameState.pendingSpellNotation)) {
                cancelButton.style.display = 'block';
            } else {
                cancelButton.style.display = 'none';
            }
        }
        
        function updateNavigationButtons() {
            historyBackButtons.forEach(btn => btn.disabled = gameState.currentHistoryViewIndex <= 0);
            historyForwardButtons.forEach(btn => btn.disabled = gameState.currentHistoryViewIndex >= gameState.history.length - 1);
        }

        function updateSpellControls() {
            const isViewingLatest = gameState.currentHistoryViewIndex === gameState.history.length - 1;
            const disableControls = gameState.awaitingPromotion || (gameState.isGameOver && isViewingLatest);

            ['white', 'black'].forEach(player => {
                const spells = gameState.spells[player];
                let currentCastingGameTurnForCheck = gameState.gameTurnNumber;

                // If it's White's turn, it means Black has just finished their move.
                // The gameTurnNumber has just incremented. For the purpose of calculating
                // Black's cooldown, we should use the previous turn number, because their
                // cooldown doesn't advance until White finishes *this* turn.
                if (player === 'black' && gameState.currentPlayer === 'white' && gameState.plyCount > 0) {
                    currentCastingGameTurnForCheck--;
                }
                
                const spellTypes = ['jump', 'freeze'];
                spellTypes.forEach(type => {
                    const count = spells[type];
                    const lastUsedTurn = spells[`${type}LastUsedTurn`];
                    
                    const btn = document.getElementById(`${player}-${type}-spell`);
                    const countEl = document.getElementById(`${player}-${type}-count`);
                    const cooldownEl = document.getElementById(`${player}-${type}-cooldown`);
                    const iconsContainer = document.getElementById(`${player}-${type}-icons`);
                    const cooldownBarFill = document.getElementById(`${player}-${type}-cooldown-bar`);

                    countEl.textContent = count;
                    iconsContainer.innerHTML = '';
                    for (let i = 0; i < count; i++) {
                        const iconSpan = document.createElement('span');
                        iconSpan.className = 'spell-icon';
                        iconSpan.textContent = type === 'jump' ? '‚ö°' : '‚ùÑÔ∏è';
                        iconsContainer.appendChild(iconSpan);
                    }

                    let onCooldown = lastUsedTurn > 0 && currentCastingGameTurnForCheck < lastUsedTurn + 3;
                    let progress = 1;
                    if (onCooldown) {
                        const turnsPassed = currentCastingGameTurnForCheck - lastUsedTurn;
                        progress = turnsPassed / 3;
                        cooldownEl.textContent = `Ready on turn ${lastUsedTurn + 3}`;
                        cooldownBarFill.classList.remove('ready');
                    } else {
                        cooldownEl.textContent = 'Ready';
                        cooldownBarFill.classList.add('ready');
                    }
                    cooldownBarFill.style.width = `${progress * 100}%`;

                    let btnDisabled = disableControls || 
                                       player !== gameState.currentPlayer || 
                                       count === 0 || 
                                       onCooldown ||
                                       !!gameState.pendingSpellNotation ||
                                       (gameState.spellMode && gameState.spellMode !== type && gameState.spellCaster === player);
                    btn.disabled = btnDisabled;
                    btn.classList.toggle('targeting', !disableControls && gameState.spellMode === type && gameState.spellCaster === player);
                });
            });
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const gameData = urlParams.get('game');
            
            document.addEventListener('keydown', (event) => {
                if (event.target.tagName === 'INPUT' || event.target.tagName === 'BUTTON' || event.target.tagName === 'TEXTAREA') {
                    return;
                }
                if (event.key === 'ArrowLeft') {
                    event.preventDefault(); 
                    if (!historyBackButtons[0].disabled) handleHistoryBack();
                } else if (event.key === 'ArrowRight') {
                    event.preventDefault();
                    if (!historyForwardButtons[0].disabled) handleHistoryForward();
                }
            });

            if (gameData) {
                resetGame(true);
                try {
                    if (gameData.startsWith('v2:')) {
                        processImportFromCompactStringV2(gameData.substring(3));
                    } else { // Handle original v1 format
                        const compactStringV1 = atob(decodeURIComponent(gameData));
                        processImportFromCompactStringV1(compactStringV1);
                    }
                } catch(e) {
                    console.error("Failed to load game from URL:", e);
                    alert("Could not load game from URL. The link may be corrupted or from a buggy older version. Starting a new game.");
                    resetGame(true);
                }
            } else {
                const savedDataScript = document.getElementById('savedGameStateData');
                const mainBody = document.body; 

                if (savedDataScript && savedDataScript.textContent.trim() !== "") {
                    try {
                        initialGameDataFromSave = JSON.parse(savedDataScript.textContent);
                        mainBody.classList.remove('home-view'); 
                        mainBody.classList.add('game-view');
                    } catch (e) {
                        console.error("Error parsing saved game data:", e);
                        initialGameDataFromSave = null;
                    }
                }
                resetGame(); 
            }
        });
        
        document.getElementById('white-jump-spell').addEventListener('click', () => activateSpellMode('jump'));
        document.getElementById('white-freeze-spell').addEventListener('click', () => activateSpellMode('freeze'));
        document.getElementById('black-jump-spell').addEventListener('click', () => activateSpellMode('jump'));
        document.getElementById('black-freeze-spell').addEventListener('click', () => activateSpellMode('freeze'));

        const copyAction = () => {
            let notationString = '';
            let lastTurnNumber = 0;
            
            if (gameState.moveLog.length === 0) {
                updateStatus("No moves to copy.");
                return;
            }

            gameState.moveLog.forEach(move => {
                if (move.turn !== lastTurnNumber) {
                    notationString += `${move.turn}. `;
                    lastTurnNumber = move.turn;
                }
                notationString += `${move.notation} `;
            });
            notationString = notationString.trim();
            
            navigator.clipboard.writeText(notationString).then(() => {
                updateStatus("Game notation copied to clipboard!");
            }).catch(err => {
                console.error('Failed to copy notation: ', err);
                updateStatus("Failed to copy. See console for details.");
            });
        };
        copyNotationButtons.forEach(btn => btn.addEventListener('click', copyAction));
        
        importGameButton.addEventListener('click', () => {
            importGameArea.style.display = 'block';
        });

        cancelImportButton.addEventListener('click', () => {
            importGameArea.style.display = 'none';
        });

        loadGameButton.addEventListener('click', () => {
            const notationText = importGameTextarea.value.trim();
            if (!notationText) {
                alert("Notation field is empty.");
                return;
            }
            processImport(notationText);
            importGameArea.style.display = 'none';
            importGameTextarea.value = '';
        });
        
        function parseAlgebraicToCoords(alg) {
            if (!alg || alg.length !== 2) return null;
            const file = alg.charCodeAt(0) - 'a'.charCodeAt(0);
            const rank = 8 - parseInt(alg[1], 10);
            if (file < 0 || file > 7 || isNaN(rank) || rank < 0 || rank > 7) return null;
            return { r: rank, c: file };
        }

        async function processImport(notationText) {
            resetGame(true); // Start with a fresh board
            updateStatus("Importing game...");
            
            let tokens = notationText.replace(/\d+\./g, '').trim().split(/\s+/);
            const lastToken = tokens[tokens.length-1].toUpperCase();
            let gameResultToken = null;

            if(['T', 'R', 'D'].includes(lastToken)) {
                gameResultToken = tokens.pop();
            }
            
            for (const token of tokens) {
                if (gameState.isGameOver) break;

                if (token.toUpperCase() === 'P') {
                    continue; // Ignore "pass" tokens used as placeholders for resignations.
                }

                if (token.includes('@')) { // It's a spell
                    const [spellTypeStr, targetSquare] = token.split('@');
                    const spellType = spellTypeStr === 'jump' ? 'jump' : 'freeze';
                    const coords = parseAlgebraicToCoords(targetSquare);
                    if (!coords) {
                        alert(`Invalid spell target: ${token}`);
                        resetGame(true);
                        return;
                    }
                    activateSpellMode(spellType);
                    handleSpellTargeting(coords.r, coords.c);

                } else { // It's a move
                    const moveCoords = findMoveFromSAN(token);
                    if (!moveCoords) {
                        alert(`Could not find a legal move for: "${token}" for ${gameState.currentPlayer} in the current position. Import failed.`);
                        resetGame(true);
                        return;
                    }
                    
                    // Simulate the two clicks to make a move
                    onSquareClick(moveCoords.fromR, moveCoords.fromC);
                    onSquareClick(moveCoords.toR, moveCoords.toC);

                    // Handle promotion if necessary
                    if (token.includes('=')) {
                        const promotionPiece = token.slice(-1);
                         if (gameState.awaitingPromotion) {
                             const promotionButton = promotionChoicesDiv.querySelector(`[data-promote="${promotionPiece}"]`);
                             if (promotionButton) {
                                 promotionButton.click();
                             } else {
                                alert(`Invalid promotion piece in: ${token}`);
                                resetGame(true);
                                return;
                             }
                         }
                    }
                }
                 await new Promise(resolve => setTimeout(resolve, 10)); // Tiny delay to allow UI to update
            }

            if(gameResultToken) {
                gameState.isGameOver = true;
                const playerWhoseTurnItIs = gameState.currentPlayer;
                let winner = "";
                let message = "";
                let notation = "";

                switch(gameResultToken.toUpperCase()) {
                    case 'T': // Timeout
                        winner = playerWhoseTurnItIs === 'white' ? 'Black' : 'White'; // The player whose turn it is loses on time
                        message = `${winner} wins by timeout.`;
                        notation = "T";
                        break;
                    case 'R': // Resignation
                        winner = playerWhoseTurnItIs === 'white' ? 'White' : 'Black'; // The player whose turn it is wins (opponent resigned)
                        message = `${winner} wins by resignation.`;
                        notation = "R";
                        break;
                    case 'D': // Draw
                        message = "Draw by agreement.";
                        notation = "D";
                        break;
                }
                gameState.gameEndMessage = message;
                 gameState.moveLog.push({ 
                    turn: gameState.gameTurnNumber, 
                    player: playerWhoseTurnItIs, 
                    notation: notation, 
                    actions: [], 
                    plySnapshotIndex: gameState.history.length
                });
            }

            updateStatus("Game import complete!");
            loadStateFromHistory(gameState.history.length-1, true);
        }

        function findMoveFromSAN(san) {
            // Handle Castling first, as it's a unique notation
            if (san.startsWith('O-O-O') || san.startsWith('0-0-0')) {
                const r = gameState.currentPlayer === 'white' ? 7 : 0;
                return { fromR: r, fromC: 4, toR: r, toC: 2 };
            }
            if (san.startsWith('O-O') || san.startsWith('0-0')) {
                const r = gameState.currentPlayer === 'white' ? 7 : 0;
                return { fromR: r, fromC: 4, toR: r, toC: 6 };
            }

            let pieceType;
            let toSquare;
            let fromFile = -1, fromRank = -1;
            
            let cleanSan = san.replace(/[x+#=]/g, '').replace('e.p.', '');
            
            // Determine piece type
            if ('RNBQK'.includes(cleanSan[0])) {
                pieceType = cleanSan[0];
                cleanSan = cleanSan.substring(1);
            } else {
                pieceType = 'P';
            }

            // Handle promotion piece
            if (cleanSan.length > 2 && 'RNBQ'.includes(cleanSan.slice(-1))) {
                cleanSan = cleanSan.slice(0, -1);
            }

            // Determine target square and disambiguation
            toSquare = cleanSan.slice(-2);
            const disambiguation = cleanSan.slice(0, -2);
            if (disambiguation) {
                if (disambiguation.length === 1) {
                    if ('abcdefgh'.includes(disambiguation)) {
                        fromFile = disambiguation.charCodeAt(0) - 'a'.charCodeAt(0);
                    } else {
                        fromRank = 8 - parseInt(disambiguation, 10);
                    }
                } else if (disambiguation.length === 2) {
                    fromFile = disambiguation.charCodeAt(0) - 'a'.charCodeAt(0);
                    fromRank = 8 - parseInt(disambiguation[1], 10);
                }
            }
            
            const toCoords = parseAlgebraicToCoords(toSquare);
            if (!toCoords) return null;

            // Find all pieces of the correct type and color
            const candidatePieces = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const p = gameState.board[r][c];
                    if (p && p.color === gameState.currentPlayer && p.type.toUpperCase() === pieceType) {
                        candidatePieces.push({ r, c });
                    }
                }
            }

            // Filter by disambiguation and find the valid move
            for (const candidate of candidatePieces) {
                if (fromFile !== -1 && candidate.c !== fromFile) continue;
                if (fromRank !== -1 && candidate.r !== fromRank) continue;

                if (isValidMove(candidate.r, candidate.c, toCoords.r, toCoords.c, gameState.board, gameState.currentPlayer, gameState.enPassantTarget, gameState.castlingRights, gameState.activeSpells, gameState.plyCount)) {
                    return { fromR: candidate.r, fromC: candidate.c, toR: toCoords.r, toC: toCoords.c };
                }
            }

            return null; // No valid move found
        }
        
        getLinkButton.addEventListener('click', () => {
            const baseURL = window.location.href.split('?')[0];
            if (gameState.moveLog.length === 0) {
                updateStatus("No moves to create a link from.");
                return;
            }
            const compactString = gameState.moveLog.flatMap(log => log.actions).join('');
            const finalURL = `${baseURL}?game=v2:${compactString}`;

            navigator.clipboard.writeText(finalURL).then(() => {
                const originalText = getLinkButton.textContent;
                getLinkButton.textContent = 'Copied!';
                updateStatus("Custom game link copied to clipboard!");
                setTimeout(() => {
                    getLinkButton.textContent = originalText;
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy link: ', err);
                updateStatus("Failed to copy link. See console.");
            });
        });
        
        async function processImportFromCompactStringV1(compactString) {
            updateStatus("Importing game from URL (v1)...");
            const actions = compactString.split(',');

            for (const action of actions) {
                if (gameState.isGameOver) break;

                if (action.includes('@')) { // Spell
                    const [spellTypeChar, targetSquare] = action.split('@');
                    const spellType = spellTypeChar === 'j' ? 'jump' : 'freeze';
                    const coords = parseAlgebraicToCoords(targetSquare);
                    if (!coords) throw new Error(`Invalid spell target in URL: ${action}`);
                    activateSpellMode(spellType);
                    handleSpellTargeting(coords.r, coords.c);

                } else { // Move
                    const [fromAlg, toAndPromo] = action.split('-');
                    const toAlg = toAndPromo.substring(0, 2);
                    const fromCoords = parseAlgebraicToCoords(fromAlg);
                    const toCoords = parseAlgebraicToCoords(toAlg);
                    if (!fromCoords || !toCoords) throw new Error(`Invalid move coordinates in URL: ${action}`);

                    onSquareClick(fromCoords.r, fromCoords.c);
                    onSquareClick(toCoords.r, toCoords.c);
                    
                    if (toAndPromo.includes('=')) {
                        const promoPiece = toAndPromo.split('=')[1];
                        if (gameState.awaitingPromotion) {
                            const promoButton = promotionChoicesDiv.querySelector(`[data-promote="${promoPiece}"]`);
                            if (promoButton) {
                                promoButton.click();
                            } else {
                                throw new Error(`Invalid promotion in URL: ${action}`);
                            }
                        }
                    }
                }
                 await new Promise(resolve => setTimeout(resolve, 10)); // Tiny delay
            }
            updateStatus("Game loaded from URL successfully!");
        }

        async function processImportFromCompactStringV2(str) {
            updateStatus("Importing game from URL...");
            let i = 0;
            while (i < str.length) {
                if (gameState.isGameOver) break;

                let turnActions = { spell: null, move: null, promo: null };

                // 1. Check for an optional spell
                const char1 = str[i];
                if (char1 === '.' || char1 === '~') {
                    const spellType = char1 === '.' ? 'jump' : 'freeze';
                    const targetChar = str[i + 1];
                    const coords = b64ToCoord(targetChar);
                    if (!coords) throw new Error(`Invalid spell target char in URL`);
                    turnActions.spell = { type: spellType, r: coords.r, c: coords.c };
                    i += 2;
                }

                // 2. Process the mandatory move
                if (i + 1 >= str.length) break; // End of string after a possible spell, should not happen in valid data
                const fromChar = str[i];
                const toChar = str[i + 1];
                const fromCoords = b64ToCoord(fromChar);
                const toCoords = b64ToCoord(toChar);
                if (!fromCoords || !toCoords) throw new Error("Invalid move coord chars in URL");
                turnActions.move = { fromR: fromCoords.r, fromC: fromCoords.c, toR: toCoords.r, toC: toCoords.c };
                i += 2;

                // 3. Check for optional promotion
                if (i < str.length && 'QRBN'.includes(str[i])) {
                    turnActions.promo = str[i];
                    i += 1;
                }

                // 4. Execute the turn's actions
                if (turnActions.spell) {
                    activateSpellMode(turnActions.spell.type);
                    handleSpellTargeting(turnActions.spell.r, turnActions.spell.c);
                }
                
                onSquareClick(turnActions.move.fromR, turnActions.move.fromC);
                onSquareClick(turnActions.move.toR, turnActions.move.toC);

                if (turnActions.promo && gameState.awaitingPromotion) {
                    const promoButton = promotionChoicesDiv.querySelector(`[data-promote="${turnActions.promo}"]`);
                    if (promoButton) {
                        promoButton.click();
                    } else {
                        throw new Error(`Invalid promotion during URL load`);
                    }
                }
                
                await new Promise(resolve => setTimeout(resolve, 10)); // UI update delay
            }
            updateStatus("Game loaded from URL successfully!");
        }
        
        // Dropdown Menu Logic
        optionsToggleButton.addEventListener('click', function(event) {
            optionsContent.style.display = optionsContent.style.display === 'block' ? 'none' : 'block';
            event.stopPropagation();
        });

        window.addEventListener('click', function(event) {
            if (!event.target.matches('.options-button') && optionsContent.style.display === 'block') {
                optionsContent.style.display = 'none';
            }
        });


    </script>









</body></html>
