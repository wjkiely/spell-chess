<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spell Chess</title>
    <style>
        /* Global reset/base */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            box-sizing: border-box;
        }
        *, *:before, *:after {
            box-sizing: inherit;
        }

        /* Styles for home page view */
        body.home-view {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            min-height: 100vh;
            padding: 20px;
        }
        body.home-view #game-content-wrapper {
            display: none;
        }
        body.home-view #home-page-content {
            display: block;
        }

        /* Styles for game view (Desktop First) */
        body.game-view {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
            background-color: #fff;
            min-height: 100vh;
        }
        body.game-view #home-page-content {
            display: none;
        }
        body.game-view #game-content-wrapper {
            display: block;
        }


        #home-page-content h1 {
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        #start-game-button {
            padding: 15px 30px;
            font-size: 1.2em;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            margin-bottom: 5px;
        }
        #start-game-button:hover {
            background-color: #45a049;
        }

        /* --- DESKTOP GAME STYLES --- */
        .game-container {
            display: flex;
            flex-wrap: wrap; 
            gap: 20px;
            align-items: flex-start;
            width: 100%;
            max-width: 1200px; 
            margin: 0 auto;
        }

        .main-game-area { 
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 480px; 
            flex-shrink: 0;
        }

        .status-area {
            padding: 10px;
            border: 1px solid #ccc;
            background-color: #e9ecef;
            min-height: 50px;
            width: 100%; 
            text-align: center; 
        }
        .rules-area {
            padding: 10px;
            border: 1px solid #ccc;
            background-color: #f8f9fa;
            width: 100%;
            margin-top: 10px; 
            font-size: 0.9em;
            line-height: 1.5;
        }
        .rules-area h4 {
            margin-top: 0;
            color: #333;
        }
        .rules-area ul {
            padding-left: 20px;
            margin-bottom: 0;
        }
        .rules-area li {
            margin-bottom: 5px;
        }

        .chessboard {
            width: 480px;
            height: 480px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 2px solid #333;
        }
        .square {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            cursor: pointer;
            user-select: none;
            position: relative;
        }
        .square.light { background-color: #f0d9b5; }
        .square.dark { background-color: #b58863; }
        .square.selected { background-color: #6a994e; }

        .square.valid-move-hint::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(167, 201, 87, 0.5);
            box-shadow: inset 0 0 0 2px #6a994e;
            z-index: 1;
        }
        .square.active-freeze-zone {
            box-shadow: inset 0 0 0 1000px rgba(173, 216, 230, 0.35);
        }
        .square.jumpable-on-square {
            box-shadow: inset 0 0 0 1000px rgba(255, 255, 0, 0.25),
                        inset 0 0 0 3px #DAA520;
        }
        .square.freeze-outline-top { border-top: 3px solid #007bff; }
        .square.freeze-outline-bottom { border-bottom: 3px solid #007bff; }
        .square.freeze-outline-left { border-left: 3px solid #007bff; }
        .square.freeze-outline-right { border-right: 3px solid #007bff; }

        .square-freeze-emoji {
            position: absolute;
            top: 1px;
            right: 1px;
            font-size: 15px;
            opacity: 0.9;
            z-index: 1;
            pointer-events: none;
        }
        .piece {
            position: relative;
            z-index: 2;
        }

        .controls {
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex-shrink: 0;
        }
        .player-info { padding: 10px; border: 1px solid #ccc; border-radius: 5px; }
        .player-info h3 { margin-top: 0; }
        .spell-button, .reset-button, .promotion-button { 
            padding: 8px 12px;
            cursor: pointer;
            border: 1px solid #555;
            border-radius: 4px;
            background-color: #f0f0f0;
            width: 100%;
        }
        .promotion-button {
            margin-bottom: 5px;
        }
        /* Removed specific styles for #go-home-button to make it look like .reset-button */
        /* #go-home-button {
            background-color: #6c757d; 
            color: white;
        }
        #go-home-button:hover {
            background-color: #5a6268;
        } */
        .spell-button:disabled { cursor: not-allowed; background-color: #ccc; color: #777; }
        .spell-button.targeting { background-color: #add8e6; }

        .notation-area {
            padding: 10px;
            border: 1px solid #ccc;
            height: 480px; 
            width: 360px;
            overflow-y: auto;
            background-color: #f8f9fa;
            flex-shrink: 0;
        }
        .notation-area .notation-line {
            margin-bottom: 2px;
        }
        .notation-area .notation-turn-number {
            font-weight: bold;
            margin-right: 5px;
        }
        .notation-area .notation-move {
            cursor: pointer;
            text-decoration: underline;
            color: #0056b3;
            margin-right: 5px;
        }
        .notation-area .notation-move:hover {
            color: #007bff;
        }

        #promotion-choices {
            margin-top: 10px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }


        /* --- MOBILE STYLES --- */
        @media (max-width: 768px) {
            body.game-view {
                padding: 10px;
            }
            .game-container {
                flex-direction: column; 
                align-items: center; 
                gap: 15px;
                flex-wrap: nowrap; 
            }
            .main-game-area { 
                 width: 90vw;
                 max-width: 400px; 
                 order: 1; 
                 gap: 10px;
            }
            .chessboard {
                width: 100%; 
                height: auto; 
                aspect-ratio: 1 / 1; 
                max-width: none; 
                max-height: none;
            }
            .status-area {
                 width: 100%; 
                 max-width: none; 
                 text-align: center;
            }
            .rules-area {
                font-size: 0.8em;
            }
            .square {
                font-size: 7vw;
            }
            @media (min-width: 450px) and (max-width: 768px) {
                .square {
                    font-size: 32px;
                }
            }
            .controls {
                order: 2; 
                width: 90vw;
                max-width: 480px;
            }
            .player-info {
                display: flex;
                flex-direction: column;
                align-items: stretch;
            }
            .player-info h3 {
                text-align: center;
            }
             .player-info .spell-button, .player-info small {
                width: auto;
                margin-left: auto;
                margin-right: auto;
                text-align: center;
            }
             .player-info small {
                margin-bottom: 5px;
                display: block;
             }
            .notation-area {
                order: 3; 
                width: 90vw;
                max-width: 480px;
                height: 150px;
            }
             #promotion-choices {
                order: -1;
            }
        }
        @media (max-width: 400px) {
            .square {
                font-size: 28px;
            }
            .player-info h3 {
                font-size: 1em;
            }
            .spell-button, .reset-button, .promotion-button {
                padding: 6px 10px;
                font-size: 0.9em;
            }
            .main-game-area { 
                width: 95vw; 
            }
            .controls, .notation-area {
                 width: 95vw;
            }
        }
    </style>
</head>
<body class="home-view">

    <div id="home-page-content">
        <h1>Spell Chess</h1>
        <button id="start-game-button">Two Player Game</button>
    </div>

    <div id="game-content-wrapper">
        <div class="game-container">
            <div class="main-game-area">
                <div id="chessboard" class="chessboard"></div>
                <div id="status-area" class="status-area">White's turn.</div>
                <div id="rules-area" class="rules-area">
                    <h4>Spell Chess Rules:</h4>
                    <ul>
                        <li>Standard chess rules apply.</li>
                        <li>Each player starts the game with two Jump spells and five Freeze spells.</li>
                        <li>A player may cast a spell before making their move.</li>
                        <li><strong>Jump Spell:</strong> Target any piece. For your current move and your opponent's next move, that piece is jumpable by other pieces as if it is not there.</li>
                        <li><strong>Freeze Spell:</strong> Target any square. All pieces in a 3x3 area around the target square are frozen and cannot move on your turn or your opponent's next turn. Frozen pieces cannot put a king in check or checkmate.</li>
                        <li>Spells have a 3-turn cooldown before they can be used again.</li>
                        <li>Checkmate or capture your opponent's king to win.</li>
                    </ul>
                </div>
            </div>
            <div class="controls">
                <div id="white-player-info" class="player-info">
                    <h3>White</h3>
                    <button id="white-jump-spell" class="spell-button">Cast Jump (<span id="white-jump-count">2</span>)</button>
                    <small id="white-jump-cooldown"></small>
                    <button id="white-freeze-spell" class="spell-button">Cast Freeze (<span id="white-freeze-count">5</span>)</button>
                    <small id="white-freeze-cooldown"></small>
                </div>
                <div id="black-player-info" class="player-info">
                    <h3>Black</h3>
                    <button id="black-jump-spell" class="spell-button">Cast Jump (<span id="black-jump-count">2</span>)</button>
                    <small id="black-jump-cooldown"></small>
                    <button id="black-freeze-spell" class="spell-button">Cast Freeze (<span id="black-freeze-count">5</span>)</button>
                    <small id="black-freeze-cooldown"></small>
                </div>
                
                <button id="download-game-button" class="reset-button">Download Game</button>
                <button id="reset-game-button" class="reset-button">Reset Game</button>
                <button id="go-home-button" class="reset-button">Home</button>
                
                <div id="promotion-choices" style="display:none;">
                    <button class="promotion-button" data-promote="Q">Promote to Queen</button>
                    <button class="promotion-button" data-promote="R">Promote to Rook</button>
                    <button class="promotion-button" data-promote="B">Promote to Bishop</button>
                    <button class="promotion-button" data-promote="N">Promote to Knight</button>
                </div>
                <button id="cancel-button" class="reset-button" style="display:none; margin-top:10px; width:100%;">Cancel</button>
            </div>
            <div id="notation-area" class="notation-area"></div>
        </div>
    </div>

    <script id="savedGameStateData" type="application/json"></script>

    <script id="home-page-script">
        const startGameButton = document.getElementById('start-game-button');
        const goHomeButton = document.getElementById('go-home-button');
        const mainBody = document.body;

        startGameButton.addEventListener('click', function() {
            mainBody.classList.remove('home-view');
            mainBody.classList.add('game-view');
        });

        goHomeButton.addEventListener('click', function() {
            mainBody.classList.remove('game-view');
            mainBody.classList.add('home-view');
            if (typeof resetGame === 'function') {
                resetGame(true); 
            }
        });
    </script>

    <script id="spell-chess-game-script">
        const PIECES = {
            'P': '♙', 'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔',
            'p': '♟', 'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚'
        };

        const initialBoardSetup = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];

        let gameState;
        let initialGameDataFromSave = null;

        const chessboardDiv = document.getElementById('chessboard');
        const statusArea = document.getElementById('status-area');
        const notationArea = document.getElementById('notation-area');
        const cancelButton = document.getElementById('cancel-button'); 
        const promotionChoicesDiv = document.getElementById('promotion-choices');
        const downloadGameButton = document.getElementById('download-game-button');

        function deepCopyGameStateForSnapshot(sourceState) { 
            if (!sourceState) return null;
            const target = {};
            for (const key in sourceState) {
                if (Object.prototype.hasOwnProperty.call(sourceState, key)) {
                    if (key === 'history' || key === 'moveLog') { 
                        continue; 
                    }
                    const value = sourceState[key];
                    if (typeof value === 'object' && value !== null) {
                        target[key] = JSON.parse(JSON.stringify(value));
                    } else {
                        target[key] = value;
                    }
                }
            }
            return target;
        }
        
        function deepCopyFullState(sourceState) {
            return JSON.parse(JSON.stringify(sourceState));
        }

        function initializeGameState() {
            gameState = {
                board: [],
                currentPlayer: 'white',
                gameTurnNumber: 1,
                whitePlayerTurn: 1, 
                blackPlayerTurn: 1, 
                plyCount: 0, 
                spells: {
                    white: { jump: 2, freeze: 5, jumpLastUsedTurn: 0, freezeLastUsedTurn: 0 },
                    black: { jump: 2, freeze: 5, jumpLastUsedTurn: 0, freezeLastUsedTurn: 0 }
                },
                activeSpells: [],
                selectedPiece: null,
                spellMode: null,
                spellCaster: null,
                spellActivationState: null,
                pendingSpellNotation: null,
                moveLog: [], 
                enPassantTarget: null,
                castlingRights: {
                    white: { K: true, Q: true },
                    black: { k: true, q: true }
                },
                isGameOver: false,
                gameEndMessage: "", 
                awaitingPromotion: null,
                history: [] 
            };
        }

        function initializeBoardState() {
            gameState.board = initialBoardSetup.map((row, r) =>
                row.map((pieceType, c) => {
                    if (!pieceType) return null;
                    const color = (pieceType === pieceType.toUpperCase()) ? 'white' : 'black';
                    return {
                        type: pieceType,
                        color: color,
                        id: `piece-${r}-${c}-${Date.now()}`, 
                        isFrozen: false,
                        isJumpable: false,
                        hasMoved: false
                    };
                })
            );
        }

        function resetGame(forceNewGame = false) {
            if (!forceNewGame && initialGameDataFromSave) {
                gameState = deepCopyFullState(initialGameDataFromSave); 
                initialGameDataFromSave = null; 
                console.log("Game loaded from saved state.");
                document.body.classList.remove('home-view');
                document.body.classList.add('game-view');
            } else {
                initializeGameState();
                initializeBoardState();
                const initialSnapshot = deepCopyGameStateForSnapshot(gameState); 
                gameState.history.push(initialSnapshot);
                console.log("New game started.");
            }

            promotionChoicesDiv.style.display = 'none';
            renderBoard();
            updateSpellControls();
            updateCancelButtonVisibility();
            updateNotationDisplay();

            if (gameState.isGameOver) {
                updateStatus(gameState.gameEndMessage || "Game over.");
            } else if (gameState.awaitingPromotion) {
                updateStatus(`Choose promotion for pawn at ${String.fromCharCode(97 + gameState.awaitingPromotion.c)}${8 - gameState.awaitingPromotion.r}.`);
            } else {
                let statusMsg = `${gameState.currentPlayer.charAt(0).toUpperCase() + gameState.currentPlayer.slice(1)}'s turn.`;
                 if (gameState.board && gameState.board.length > 0 && 
                    isKingInCheck(gameState.currentPlayer, gameState.board, gameState.enPassantTarget, gameState.activeSpells, gameState.plyCount)) {
                    statusMsg += " Check!";
                }
                updateStatus(statusMsg);
            }
        }

        document.getElementById('reset-game-button').addEventListener('click', () => resetGame(true)); 
        cancelButton.addEventListener('click', handleCancelAction); 

        promotionChoicesDiv.addEventListener('click', function(event) {
            if (event.target.classList.contains('promotion-button') && gameState.awaitingPromotion) {
                const chosenPieceType = event.target.dataset.promote;
                const { r, c, color, originalMoveNotation, movingPiece, fromR, fromC } = gameState.awaitingPromotion;

                gameState.board[r][c].type = (color === 'white') ? chosenPieceType.toUpperCase() : chosenPieceType.toLowerCase();
                
                const finalMoveNotation = originalMoveNotation + "=" + chosenPieceType.toUpperCase(); 

                gameState.awaitingPromotion = null;
                promotionChoicesDiv.style.display = 'none';
                updateCancelButtonVisibility(); 
                
                renderBoard(); 
                endTurn(finalMoveNotation, movingPiece, fromR, r, fromC);
            }
        });

        downloadGameButton.addEventListener('click', () => { 
            if (gameState.awaitingPromotion) {
                alert("Cannot download game while awaiting pawn promotion.");
                return;
            }
            const stateToSave = deepCopyFullState(gameState);
            const serializedState = JSON.stringify(stateToSave);

            const clonedDocument = document.cloneNode(true);
            
            let existingSavedScriptInClone = clonedDocument.getElementById('savedGameStateData');
            if (existingSavedScriptInClone) {
                existingSavedScriptInClone.textContent = serializedState; 
            } else { 
                const scriptTag = clonedDocument.createElement('script');
                scriptTag.id = 'savedGameStateData';
                scriptTag.type = 'application/json'; 
                scriptTag.textContent = serializedState;
                clonedDocument.head.appendChild(scriptTag);
            }

            const fullHtmlContent = '<!DOCTYPE html>\n' + clonedDocument.documentElement.outerHTML;
            const blob = new Blob([fullHtmlContent], { type: 'text/html;charset=utf-8' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            
            let filename = "Spell_chess.html"; 
            if (gameState.moveLog.length > 0) {
                const lastFullTurnEntryIndex = gameState.moveLog.length - 1;
                let turnNumberForFile = gameState.moveLog[lastFullTurnEntryIndex].turn;
                let whiteMoveForFile = "";
                let blackMoveForFile = "";

                for(let i = lastFullTurnEntryIndex; i >=0; i--){
                    if(gameState.moveLog[i].turn === turnNumberForFile && gameState.moveLog[i].player === 'white'){
                        whiteMoveForFile = gameState.moveLog[i].notation.replace(/[#+=\s@]/g, '');
                        break;
                    }
                     if(gameState.moveLog[i].turn < turnNumberForFile) break;
                }
                for(let i = lastFullTurnEntryIndex; i >=0; i--){
                     if(gameState.moveLog[i].turn === turnNumberForFile && gameState.moveLog[i].player === 'black'){
                        blackMoveForFile = gameState.moveLog[i].notation.replace(/[#+=\s@]/g, '');
                        break;
                    }
                    if(gameState.moveLog[i].turn < turnNumberForFile) break;
                }
                
                filename = `${turnNumberForFile}`;
                if (whiteMoveForFile) {
                    filename += whiteMoveForFile;
                }
                if (blackMoveForFile) {
                     filename += (whiteMoveForFile ? "_" : "") + blackMoveForFile;
                }
                filename += ".html";
            }
            link.download = filename;

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
        });

        function renderBoard() {
            chessboardDiv.innerHTML = '';
            const validMovesForSelected = gameState.selectedPiece ? getValidMovesForPiece(gameState.selectedPiece.r, gameState.selectedPiece.c) : [];

            gameState.board.forEach((row, r_idx) => {
                row.forEach((piece, c_idx) => {
                    const square = document.createElement('div');
                    square.classList.add('square');
                    square.classList.add((r_idx + c_idx) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.r = r_idx;
                    square.dataset.c = c_idx;

                    square.classList.remove('active-freeze-zone', 'jumpable-on-square',
                                            'freeze-outline-top', 'freeze-outline-bottom',
                                            'freeze-outline-left', 'freeze-outline-right');

                    if (isSquareUnderActiveFreeze(r_idx, c_idx, gameState.activeSpells, gameState.plyCount)) {
                        square.classList.add('active-freeze-zone');
                        const freezeEmojiSpan = document.createElement('span');
                        freezeEmojiSpan.classList.add('square-freeze-emoji');
                        freezeEmojiSpan.textContent = '❄️';
                        square.appendChild(freezeEmojiSpan);
                    } else if (piece && piece.isJumpable) {
                        square.classList.add('jumpable-on-square');
                    }

                    gameState.activeSpells.forEach(spell => {
                        if (spell.type === 'freeze' && gameState.plyCount < spell.expiresAtPly) {
                            const spellCenterR = spell.targetSquare.r;
                            const spellCenterC = spell.targetSquare.c;
                            const minEffectR = Math.max(0, spellCenterR - 1);
                            const maxEffectR = Math.min(7, spellCenterR + 1);
                            const minEffectC = Math.max(0, spellCenterC - 1);
                            const maxEffectC = Math.min(7, spellCenterC + 1);
                            if (r_idx >= minEffectR && r_idx <= maxEffectR && c_idx >= minEffectC && c_idx <= maxEffectC) {
                                if (r_idx === minEffectR) square.classList.add('freeze-outline-top');
                                if (r_idx === maxEffectR) square.classList.add('freeze-outline-bottom');
                                if (c_idx === minEffectC) square.classList.add('freeze-outline-left');
                                if (c_idx === maxEffectC) square.classList.add('freeze-outline-right');
                            }
                        }
                    });

                    if (piece) {
                        const pieceSpan = document.createElement('span');
                        pieceSpan.classList.add('piece');
                        pieceSpan.textContent = PIECES[piece.type];
                        pieceSpan.dataset.pieceId = piece.id;
                        square.appendChild(pieceSpan);
                    }

                    if (gameState.selectedPiece && gameState.selectedPiece.r === r_idx && gameState.selectedPiece.c === c_idx) {
                        square.classList.add('selected');
                    }

                    if (validMovesForSelected.some(move => move.toR === r_idx && move.toC === c_idx)) {
                       square.classList.add('valid-move-hint');
                    }

                    square.addEventListener('click', () => onSquareClick(r_idx, c_idx));
                    chessboardDiv.appendChild(square);
                });
            });
        }

        function isSquareUnderActiveFreeze(sqR, sqC, activeSpells, currentPly) {
            for (const spell of activeSpells) {
                if (spell.type === 'freeze' && currentPly < spell.expiresAtPly) {
                    const centerR = spell.targetSquare.r;
                    const centerC = spell.targetSquare.c;
                    if (Math.abs(sqR - centerR) <= 1 && Math.abs(sqC - centerC) <= 1) {
                        if (sqR >= Math.max(0, centerR -1) && sqR <= Math.min(7, centerR + 1) &&
                            sqC >= Math.max(0, centerC -1) && sqC <= Math.min(7, centerC + 1)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function onSquareClick(r_clicked, c_clicked) {
            if (gameState.isGameOver || gameState.awaitingPromotion) { 
                if (gameState.awaitingPromotion) updateStatus("Choose promotion piece.");
                else updateStatus("Game is over. Please reset to play again.");
                return;
            }

            const pieceAtClickedSquare = gameState.board[r_clicked][c_clicked];

            if (gameState.spellMode) {
                handleSpellTargeting(r_clicked, c_clicked);
                return;
            }

            if (gameState.selectedPiece) {
                const { r: fromR, c: fromC, piece: movingPiece } = gameState.selectedPiece;

                if (isValidMove(fromR, fromC, r_clicked, c_clicked, gameState.board, gameState.currentPlayer, gameState.enPassantTarget, gameState.castlingRights, gameState.activeSpells, gameState.plyCount)) {
                    let capturedPiece = gameState.board[r_clicked][c_clicked];
                    let moveNotation = "";
                    let isEnPassantCapture = false;
                    let isCastle = false;

                    if (movingPiece.type.toLowerCase() === 'k' && Math.abs(fromC - c_clicked) === 2) {
                        isCastle = true;
                        const isKingside = c_clicked > fromC;
                        moveNotation = isKingside ? "O-O" : "O-O-O";

                        gameState.board[r_clicked][c_clicked] = movingPiece;
                        gameState.board[fromR][fromC] = null;
                        movingPiece.hasMoved = true;

                        const rookFromC = isKingside ? 7 : 0;
                        const rookToC = isKingside ? c_clicked - 1 : c_clicked + 1;
                        const rook = gameState.board[fromR][rookFromC];
                        if (rook) {
                            gameState.board[fromR][rookToC] = rook;
                            gameState.board[fromR][rookFromC] = null;
                            rook.hasMoved = true;
                        }
                        if (gameState.currentPlayer === 'white') {
                            gameState.castlingRights.white.K = false;
                            gameState.castlingRights.white.Q = false;
                        } else {
                            gameState.castlingRights.black.k = false;
                            gameState.castlingRights.black.q = false;
                        }
                    } else {
                        if (movingPiece.type.toLowerCase() === 'p' &&
                            Math.abs(fromC - c_clicked) === 1 &&
                            !gameState.board[r_clicked][c_clicked] &&
                            gameState.enPassantTarget &&
                            r_clicked === gameState.enPassantTarget.r &&
                            c_clicked === gameState.enPassantTarget.c) {

                            isEnPassantCapture = true;
                            const epCapturedPawnActualR = fromR;
                            const epCapturedPawnActualC = c_clicked;
                            capturedPiece = gameState.board[epCapturedPawnActualR][epCapturedPawnActualC];
                            gameState.board[epCapturedPawnActualR][epCapturedPawnActualC] = null;
                            moveNotation = generateMoveNotation(movingPiece, fromR, fromC, r_clicked, c_clicked, capturedPiece, true);
                        } else {
                             moveNotation = generateMoveNotation(movingPiece, fromR, fromC, r_clicked, c_clicked, capturedPiece);
                        }
                        
                        gameState.board[r_clicked][c_clicked] = movingPiece;
                        movingPiece.hasMoved = true;
                        gameState.board[fromR][fromC] = null;

                        if (movingPiece.type.toLowerCase() === 'k') {
                            if (movingPiece.color === 'white') {
                                gameState.castlingRights.white.K = false;
                                gameState.castlingRights.white.Q = false;
                            } else {
                                gameState.castlingRights.black.k = false;
                                gameState.castlingRights.black.q = false;
                            }
                        } else if (movingPiece.type.toLowerCase() === 'r') {
                            if (movingPiece.color === 'white') {
                                if (fromR === 7 && fromC === 0) gameState.castlingRights.white.Q = false;
                                if (fromR === 7 && fromC === 7) gameState.castlingRights.white.K = false;
                            } else {
                                if (fromR === 0 && fromC === 0) gameState.castlingRights.black.q = false;
                                if (fromR === 0 && fromC === 7) gameState.castlingRights.black.k = false;
                            }
                        }
                    }

                    gameState.selectedPiece = null; 

                    if (!isCastle && movingPiece.type.toLowerCase() === 'p' &&
                        ((movingPiece.color === 'white' && r_clicked === 0) || (movingPiece.color === 'black' && r_clicked === 7))) {
                        
                        gameState.awaitingPromotion = {
                            r: r_clicked,
                            c: c_clicked,
                            color: movingPiece.color,
                            originalMoveNotation: moveNotation,
                            movingPiece: gameState.board[r_clicked][c_clicked], 
                            fromR: fromR, 
                            fromC: fromC  
                        };
                        promotionChoicesDiv.style.display = 'flex'; 
                        cancelButton.style.display = 'none'; 
                        updateStatus(`Choose promotion for pawn at ${String.fromCharCode(97 + c_clicked)}${8 - r_clicked}.`);
                        renderBoard(); 
                        return; 
                    }
                    
                    const pieceToEndTurnWith = gameState.board[r_clicked][c_clicked] || movingPiece; 
                    endTurn(moveNotation, pieceToEndTurnWith, fromR, r_clicked, fromC);
                } else if (pieceAtClickedSquare && pieceAtClickedSquare.color === gameState.currentPlayer) {
                    let effectivelyFrozenNewSelection = pieceAtClickedSquare.isFrozen || isSquareUnderActiveFreeze(r_clicked, c_clicked, gameState.activeSpells, gameState.plyCount);
                    if (effectivelyFrozenNewSelection) {
                        updateStatus("This piece is frozen or on a frozen square and cannot move.");
                        return; 
                    }
                    gameState.selectedPiece = { r: r_clicked, c: c_clicked, piece: pieceAtClickedSquare };
                    renderBoard();
                } else { 
                    updateStatus("Invalid move or empty square. Try again.");
                    gameState.selectedPiece = null; 
                    renderBoard();
                }
            } else { 
                if (pieceAtClickedSquare && pieceAtClickedSquare.color === gameState.currentPlayer) {
                    let effectivelyFrozenInitialSelection = pieceAtClickedSquare.isFrozen || isSquareUnderActiveFreeze(r_clicked, c_clicked, gameState.activeSpells, gameState.plyCount);
                    if (effectivelyFrozenInitialSelection) {
                        updateStatus("This piece is frozen or on a frozen square and cannot move.");
                        return;
                    }
                    gameState.selectedPiece = { r: r_clicked, c: c_clicked, piece: pieceAtClickedSquare };
                    renderBoard();
                }
            }
            updateCancelButtonVisibility(); 
        }

        function isPathClear(fromR, fromC, toR, toC, board) {
            const dr = Math.sign(toR - fromR);
            const dc = Math.sign(toC - fromC);
            let r = fromR + dr;
            let c = fromC + dc;

            while (r !== toR || c !== toC) {
                if (r < 0 || r >= 8 || c < 0 || c >= 8) return false; 
                const pieceOnPath = board[r][c];
                if (pieceOnPath && !pieceOnPath.isJumpable) { 
                    return false; 
                }
                r += dr;
                c += dc;
            }
            return true;
        }

        function isSquareAttacked(targetR, targetC, attackerColor, board, enPassantTarget, activeSpells, currentPly) {
            for (let r_attacker = 0; r_attacker < 8; r_attacker++) { 
                for (let c_attacker = 0; c_attacker < 8; c_attacker++) {
                    const piece = board[r_attacker][c_attacker];
                    if (piece && piece.color === attackerColor) {
                        let effectivelyFrozenAttacker = piece.isFrozen || isSquareUnderActiveFreeze(r_attacker, c_attacker, activeSpells, currentPly);
                        if (effectivelyFrozenAttacker) continue; 

                        const pieceType = piece.type.toLowerCase();
                        if (pieceType === 'p') {
                            const attackDR = (attackerColor === 'white') ? -1 : 1; 
                            if (r_attacker + attackDR === targetR && Math.abs(c_attacker - targetC) === 1) return true;
                        } else if (pieceType === 'n') {
                            const drAbs = Math.abs(targetR - r_attacker);
                            const dcAbs = Math.abs(targetC - c_attacker);
                            if ((drAbs === 2 && dcAbs === 1) || (drAbs === 1 && dcAbs === 2)) return true;
                        } else if (pieceType === 'r' || pieceType === 'q') { 
                            if ((r_attacker === targetR || c_attacker === targetC) && isPathClear(r_attacker, c_attacker, targetR, targetC, board)) {
                                return true;
                            }
                        } 
                        if (pieceType === 'b' || pieceType === 'q') { 
                             if (Math.abs(targetR - r_attacker) === Math.abs(targetC - c_attacker) && isPathClear(r_attacker, c_attacker, targetR, targetC, board)) {
                                return true;
                            }
                        }
                        if (pieceType === 'k') {
                            if (Math.abs(targetR - r_attacker) <= 1 && Math.abs(targetC - c_attacker) <= 1) return true;
                        }
                    }
                }
            }
            return false;
        }

        function checkCastleConditions(kingFromR, kingFromC, kingToR, kingToC, board, player, castlingRights, activeSpells, currentPly, enPassantTarget) {
            const opponentColor = player === 'white' ? 'black' : 'white';
            const king = board[kingFromR][kingFromC];

            if (!king || king.hasMoved) return false; 

            if (isKingInCheck(player, board, enPassantTarget, activeSpells, currentPly)) return false;

            const isKingside = kingToC > kingFromC;

            if (isKingside) {
                if (player === 'white' && !castlingRights.white.K) return false;
                if (player === 'black' && !castlingRights.black.k) return false;
                const rook = board[kingFromR][7];
                if (!rook || rook.type.toLowerCase() !== 'r' || rook.hasMoved) return false;


                if (board[kingFromR][kingFromC + 1] || board[kingFromR][kingFromC + 2]) return false;
                
                if (isSquareAttacked(kingFromR, kingFromC + 1, opponentColor, board, enPassantTarget, activeSpells, currentPly)) return false;
                if (isSquareAttacked(kingFromR, kingFromC + 2, opponentColor, board, enPassantTarget, activeSpells, currentPly)) return false;
            } else { // Queenside
                if (player === 'white' && !castlingRights.white.Q) return false;
                if (player === 'black' && !castlingRights.black.q) return false;
                const rook = board[kingFromR][0];
                if (!rook || rook.type.toLowerCase() !== 'r' || rook.hasMoved) return false;

                if (board[kingFromR][kingFromC - 1] || board[kingFromR][kingFromC - 2] || board[kingFromR][kingFromC - 3]) return false;
                
                if (isSquareAttacked(kingFromR, kingFromC - 1, opponentColor, board, enPassantTarget, activeSpells, currentPly)) return false;
                if (isSquareAttacked(kingFromR, kingFromC - 2, opponentColor, board, enPassantTarget, activeSpells, currentPly)) return false;
            }
            return true;
        }

        function isValidMove(fromR, fromC, toR, toC, board, currentPlayer, currentEnPassantTarget, currentCastlingRights, activeSpells, currentPly) {
            const movingPiece = board[fromR][fromC];
            if (!movingPiece || movingPiece.color !== currentPlayer) return false;

            let effectivelyFrozenMovingPiece = movingPiece.isFrozen || isSquareUnderActiveFreeze(fromR, fromC, activeSpells, currentPly);
            if (effectivelyFrozenMovingPiece) return false;

            if (fromR === toR && fromC === toC) return false; 

            const targetPiece = board[toR][toC];
            if (targetPiece && targetPiece.color === movingPiece.color) return false; 

            const pieceType = movingPiece.type.toLowerCase();

            if (pieceType === 'k' && Math.abs(toC - fromC) === 2 && fromR === toR) {
                return checkCastleConditions(fromR, fromC, toR, toC, board, currentPlayer, currentCastlingRights, activeSpells, currentPly, currentEnPassantTarget);
            }

            let isValidSpecificMove = false;
            switch (pieceType) {
                case 'p':
                    const colorMultiplier = (movingPiece.color === 'white') ? -1 : 1;
                    if (toR === fromR + colorMultiplier && toC === fromC && !targetPiece) { 
                        isValidSpecificMove = true;
                    } else if (toR === fromR + 2 * colorMultiplier && toC === fromC && !movingPiece.hasMoved && !targetPiece && !board[fromR + colorMultiplier][fromC]) { 
                        isValidSpecificMove = true;
                    } else if (toR === fromR + colorMultiplier && Math.abs(toC - fromC) === 1 && targetPiece && targetPiece.color !== movingPiece.color) { 
                        isValidSpecificMove = true;
                    } else if (toR === fromR + colorMultiplier && Math.abs(toC - fromC) === 1 && !targetPiece &&
                               currentEnPassantTarget && toR === currentEnPassantTarget.r && toC === currentEnPassantTarget.c) { 
                        const epCapturedPawnActualR = fromR;
                        const epCapturedPawnActualC = toC;
                        const pawnToCapture = board[epCapturedPawnActualR]?.[epCapturedPawnActualC];
                        if (pawnToCapture && pawnToCapture.type.toLowerCase() === 'p' && pawnToCapture.color !== movingPiece.color) {
                             isValidSpecificMove = true;
                        }
                    }
                    break;
                case 'n':
                    const drN = Math.abs(toR - fromR);
                    const dcN = Math.abs(toC - fromC);
                    if ((drN === 2 && dcN === 1) || (drN === 1 && dcN === 2)) {
                        isValidSpecificMove = true;
                    }
                    break;
                case 'b':
                    if (Math.abs(toR - fromR) === Math.abs(toC - fromC)) {
                        if (isPathClear(fromR, fromC, toR, toC, board)) isValidSpecificMove = true;
                    }
                    break;
                case 'r':
                    if (fromR === toR || fromC === toC) {
                        if (isPathClear(fromR, fromC, toR, toC, board)) isValidSpecificMove = true;
                    }
                    break;
                case 'q':
                    if ((fromR === toR || fromC === toC) || (Math.abs(toR - fromR) === Math.abs(toC - fromC))) {
                        if (isPathClear(fromR, fromC, toR, toC, board)) isValidSpecificMove = true;
                    }
                    break;
                case 'k': 
                    const drK = Math.abs(toR - fromR);
                    const dcK = Math.abs(toC - fromC);
                    if (drK <= 1 && dcK <= 1) {
                        isValidSpecificMove = true;
                    }
                    break;
            }

            if (!isValidSpecificMove) return false;

            const tempBoard = board.map(row => row.map(p => p ? {...p} : null));
            const pieceToMoveCopy = tempBoard[fromR][fromC]; 
            tempBoard[toR][toC] = pieceToMoveCopy;
            tempBoard[fromR][fromC] = null;

            if (pieceType === 'p' && currentEnPassantTarget && toR === currentEnPassantTarget.r && toC === currentEnPassantTarget.c && !targetPiece) { 
                 const epCapturedPawnActualR = fromR;
                 const epCapturedPawnActualC = toC;
                 if (tempBoard[epCapturedPawnActualR] && tempBoard[epCapturedPawnActualR][epCapturedPawnActualC]) { 
                    tempBoard[epCapturedPawnActualR][epCapturedPawnActualC] = null;
                 }
            }

            let kingPos;
            const currentPlayerKingType = currentPlayer === 'white' ? 'K' : 'k';
            for (let r_king = 0; r_king < 8; r_king++) { 
                for (let c_king = 0; c_king < 8; c_king++) {
                    if (tempBoard[r_king][c_king] && tempBoard[r_king][c_king].type === currentPlayerKingType) {
                        kingPos = { r: r_king, c: c_king };
                        break;
                    }
                }
                if (kingPos) break;
            }
            
            if (!kingPos) return true; 

            const opponentColor = currentPlayer === 'white' ? 'black' : 'white';
            if (isSquareAttacked(kingPos.r, kingPos.c, opponentColor, tempBoard, null, activeSpells, currentPly )) { 
                return false; 
            }

            return true;
        }
        
        function getValidMovesForPiece(r_piece, c_piece) { 
            const refinedValidMoves = [];
            for (let tr = 0; tr < 8; tr++) {
                for (let tc = 0; tc < 8; tc++) {
                     if (isValidMove(r_piece, c_piece, tr, tc, gameState.board, gameState.currentPlayer, gameState.enPassantTarget, gameState.castlingRights, gameState.activeSpells, gameState.plyCount)) {
                        refinedValidMoves.push({ fromR: r_piece, fromC: c_piece, toR: tr, toC: tc });
                    }
                }
            }
            return refinedValidMoves;
        }

        function isKingInCheck(kingColor, board, enPassantTarget, activeSpells, currentPly) {
            let kingPos = null;
            const kingType = (kingColor === 'white') ? 'K' : 'k';
            const attackerColor = (kingColor === 'white') ? 'black' : 'white';

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c] && board[r][c].type === kingType) {
                        kingPos = { r, c };
                        break;
                    }
                }
                if (kingPos) break;
            }

            if (!kingPos) return false; 
            
            return isSquareAttacked(kingPos.r, kingPos.c, attackerColor, board, enPassantTarget, activeSpells, currentPly);
        }

        function hasLegalMoves(playerColor, board, enPassantTarget, currentCastlingRights, activeSpells, currentPly, playerSpellsState, playerTurnNumberForCooldown) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece.color === playerColor) { 
                        for (let toR = 0; toR < 8; toR++) {
                            for (let toC = 0; toC < 8; toC++) {
                                if (isValidMove(r, c, toR, toC, board, playerColor, enPassantTarget, currentCastlingRights, activeSpells, currentPly)) {
                                    return true; 
                                }
                            }
                        }
                    }
                }
            }

            const canCastFreeze = playerSpellsState.freeze > 0 && (playerSpellsState.freezeLastUsedTurn === 0 || playerTurnNumberForCooldown >= playerSpellsState.freezeLastUsedTurn + 3);
            
            if (canCastFreeze && isKingInCheck(playerColor, board, enPassantTarget, activeSpells, currentPly)) {
                for (let fr = 0; fr < 8; fr++) { 
                    for (let fc = 0; fc < 8; fc++) {
                        const tempActiveSpells = JSON.parse(JSON.stringify(activeSpells));
                        tempActiveSpells.push({
                            type: 'freeze',
                            targetSquare: { r: fr, c: fc },
                            expiresAtPly: currentPly + 2 
                        });

                        if (!isKingInCheck(playerColor, board, enPassantTarget, tempActiveSpells, currentPly + 1)) {
                            for (let pr = 0; pr < 8; pr++) {
                                for (let pc = 0; pc < 8; pc++) {
                                    const p = board[pr][pc];
                                    if (p && p.color === playerColor) {
                                        let effectivelyFrozenByTempSpells = p.isFrozen || isSquareUnderActiveFreeze(pr, pc, tempActiveSpells, currentPly + 1);
                                        if (!effectivelyFrozenByTempSpells) {
                                            return true; 
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false; 
        }

        function generateMoveNotation(piece, fromR, fromC, toR, toC, capturedPiece, isEnPassant = false) {
            let notation = "";
            const pieceTypeUpper = piece.type.toUpperCase();

            if (pieceTypeUpper !== 'P') {
                notation += pieceTypeUpper;
            } else if (capturedPiece) { 
                notation += String.fromCharCode(97 + fromC);
            }
            
            const toFile = String.fromCharCode(97 + toC);
            const toRank = 8 - toR;

            if (capturedPiece) {
                notation += 'x';
            }
            notation += toFile + toRank;

            if (isEnPassant) {
                notation += " e.p."; 
            }
            return notation;
        }
        
        function handleSpellTargeting(r_target, c_target) { 
            const targetPiece = gameState.board[r_target][c_target];
            let spellApplied = false;
            let spellNotation = "";
            const spellCaster = gameState.spellCaster; 
            const playerSpells = gameState.spells[spellCaster];
            const currentCastingGameTurn = gameState.gameTurnNumber; 

            if (gameState.spellMode === 'jump') {
                if (targetPiece) {
                    playerSpells.jump--;
                    playerSpells.jumpLastUsedTurn = currentCastingGameTurn; 
                    
                    gameState.activeSpells.push({
                        type: 'jump',
                        targetId: targetPiece.id,
                        expiresAtPly: gameState.plyCount + 2 
                    });
                    targetPiece.isJumpable = true; 
                    spellApplied = true;
                    spellNotation = `jump@${String.fromCharCode(97 + c_target)}${8 - r_target}`;
                    updateStatus(`${spellCaster.charAt(0).toUpperCase() + spellCaster.slice(1)} cast Jump on ${PIECES[targetPiece.type]} at ${String.fromCharCode(97 + c_target)}${8 - r_target}. Make your move.`);
                } else {
                    updateStatus("Jump spell must target a piece. Select a piece to Jump or Cancel.");
                    renderBoard(); 
                    updateCancelButtonVisibility(); 
                    return; 
                }
            } else if (gameState.spellMode === 'freeze') {
                playerSpells.freeze--;
                playerSpells.freezeLastUsedTurn = currentCastingGameTurn;

                const affectedPieceIds = [];
                const freezeCenterR = r_target;
                const freezeCenterC = c_target;
                
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        const nr = freezeCenterR + dr; 
                        const nc = freezeCenterC + dc; 
                        if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) { 
                            const pieceToFreeze = gameState.board[nr][nc];
                            if (pieceToFreeze) {
                                pieceToFreeze.isFrozen = true; 
                                affectedPieceIds.push(pieceToFreeze.id);
                            }
                        }
                    }
                }
                gameState.activeSpells.push({
                    type: 'freeze',
                    targetSquare: {r: freezeCenterR, c: freezeCenterC}, 
                    affectedPieceIds: affectedPieceIds, 
                    expiresAtPly: gameState.plyCount + 2 
                });
                spellApplied = true;
                spellNotation = `freeze@${String.fromCharCode(97 + c_target)}${8 - r_target}`;
                updateStatus(`${spellCaster.charAt(0).toUpperCase() + spellCaster.slice(1)} cast Freeze around ${String.fromCharCode(97 + c_target)}${8 - r_target}. Make your move.`);
            }

            if (spellApplied) {
                gameState.pendingSpellNotation = spellNotation;
                gameState.spellMode = null; 
            }
            renderBoard(); 
            updateSpellControls();
            updateCancelButtonVisibility();
        }

        function activateSpellMode(type) {
            if (gameState.isGameOver || gameState.awaitingPromotion) return; 
            if (gameState.spellMode && gameState.spellMode !== type && gameState.spellCaster === gameState.currentPlayer) { 
                updateStatus("Another spell is already being targeted. Cancel it first.");
                return;
            }
             if (gameState.spellMode === type && gameState.spellCaster === gameState.currentPlayer) { 
                handleCancelAction(); 
                return;
            }

            if (gameState.selectedPiece) {
                updateStatus("Deselect your piece before casting a spell (click an empty square or your piece again).");
                return;
            }
            if (gameState.pendingSpellNotation) { 
                updateStatus("You have already cast a spell this turn. Make your move or Cancel the cast spell.");
                return;
            }

            const playerSpells = gameState.spells[gameState.currentPlayer];
            const currentTurnForPlayerForCooldownCheck = gameState.gameTurnNumber;
            let count, lastUsedTurn, spellName;

            if (type === 'jump') {
                count = playerSpells.jump;
                lastUsedTurn = playerSpells.jumpLastUsedTurn;
                spellName = "Jump";
            } else { 
                count = playerSpells.freeze;
                lastUsedTurn = playerSpells.freezeLastUsedTurn;
                spellName = "Freeze";
            }

            if (count <= 0) {
                updateStatus(`No ${spellName} spells left.`);
                return;
            }
            if (lastUsedTurn > 0 && currentTurnForPlayerForCooldownCheck < lastUsedTurn + 3) { 
                updateStatus(`${spellName} spell is on cooldown. Available on game turn ${lastUsedTurn + 3}.`);
                return;
            }

            gameState.spellMode = type;
            gameState.spellCaster = gameState.currentPlayer;
            gameState.spellActivationState = { 
                type: type,
                originalLastUsedTurn: lastUsedTurn 
            };
            
            updateStatus(`${gameState.currentPlayer.charAt(0).toUpperCase() + gameState.currentPlayer.slice(1)} is casting ${spellName}. Select target on board or Cancel.`);
            updateSpellControls(); 
            updateCancelButtonVisibility(); 
            renderBoard(); 
        }

        function handleCancelAction() {
            if (gameState.awaitingPromotion) {
                updateStatus("Choose a promotion piece.");
                return;
            }

            let playerDisplayTurn = "";
            const caster = gameState.spellCaster || gameState.currentPlayer; 
            if (caster) {
                 playerDisplayTurn = `${caster.charAt(0).toUpperCase() + caster.slice(1)}'s turn. `;
            }

            if (gameState.pendingSpellNotation) { 
                const playerToRefund = gameState.spellCaster; 
                const playerSpells = gameState.spells[playerToRefund];
                let cancelledSpellType = "";

                if (gameState.pendingSpellNotation.startsWith('jump@')) {
                    cancelledSpellType = 'jump';
                } else if (gameState.pendingSpellNotation.startsWith('freeze@')) {
                    cancelledSpellType = 'freeze';
                }

                let spellIndexToRemove = -1;
                for (let i = gameState.activeSpells.length - 1; i >= 0; i--) {
                    const spell = gameState.activeSpells[i];
                    if (spell.type === cancelledSpellType && spell.expiresAtPly === gameState.plyCount + 2) { 
                        spellIndexToRemove = i;
                        break;
                    }
                }
                
                if (spellIndexToRemove !== -1) {
                    const spellToCancel = gameState.activeSpells[spellIndexToRemove];
                    if (cancelledSpellType === 'jump') {
                        const jumpedPiece = findPieceById(spellToCancel.targetId);
                        if (jumpedPiece) jumpedPiece.isJumpable = false;
                        playerSpells.jump++;
                        if (gameState.spellActivationState && gameState.spellActivationState.type === 'jump') {
                            playerSpells.jumpLastUsedTurn = gameState.spellActivationState.originalLastUsedTurn;
                        }
                    } else if (cancelledSpellType === 'freeze') {
                        spellToCancel.affectedPieceIds.forEach(id => {
                            const piece = findPieceById(id);
                            if (piece) piece.isFrozen = false; 
                        });
                        playerSpells.freeze++;
                        if (gameState.spellActivationState && gameState.spellActivationState.type === 'freeze') {
                            playerSpells.freezeLastUsedTurn = gameState.spellActivationState.originalLastUsedTurn;
                        }
                    }
                    gameState.activeSpells.splice(spellIndexToRemove, 1);
                }

                gameState.pendingSpellNotation = null;
                updateStatus(`${playerDisplayTurn}Spell cancelled.`);

            } else if (gameState.spellMode) { 
                updateStatus(`${playerDisplayTurn}Spell targeting cancelled.`);
            }

            gameState.spellMode = null;
            gameState.spellCaster = null;
            gameState.spellActivationState = null;

            renderBoard();
            updateSpellControls();
            updateCancelButtonVisibility();
        }
        
        function updateActiveSpells() {
            const stillActive = [];
            let boardNeedsRender = false;

            gameState.activeSpells.forEach(spell => {
                if (gameState.plyCount >= spell.expiresAtPly) { 
                    if (spell.type === 'freeze') {
                        spell.affectedPieceIds.forEach(id => { 
                            const piece = findPieceById(id);
                            if (piece) piece.isFrozen = false; 
                        });
                    } else if (spell.type === 'jump') {
                         const piece = findPieceById(spell.targetId);
                         if (piece) piece.isJumpable = false;
                    }
                    boardNeedsRender = true; 
                } else {
                    stillActive.push(spell); 
                }
            });
            gameState.activeSpells = stillActive; 
            
            if (boardNeedsRender) renderBoard(); 
        }

        function findPieceById(id) {
            for (let r_find = 0; r_find < 8; r_find++) { 
                for (let c_find = 0; c_find < 8; c_find++) {
                    if (gameState.board[r_find][c_find] && gameState.board[r_find][c_find].id === id) {
                        return gameState.board[r_find][c_find];
                    }
                }
            }
            return null;
        }

        function endTurn(moveNotation, movedPiece, fromR_param, toR_param, fromC_param) {
            const playerWhoMoved = gameState.currentPlayer; 
            
            gameState.plyCount++; 
            updateActiveSpells(); 

            let gameEndMessage = "";
            let isCheck = false;
            let isCheckmate = false;

            const opponentColor = (playerWhoMoved === 'white') ? 'black' : 'white';
            const opponentKingStillExists = gameState.board.flat().some(p => p && p.type.toLowerCase() === 'k' && p.color === opponentColor);

            if (!opponentKingStillExists) {
                isCheckmate = true; 
                gameState.isGameOver = true;
                const winner = playerWhoMoved.charAt(0).toUpperCase() + playerWhoMoved.slice(1);
                gameEndMessage = `King captured! ${winner} wins!`;
            } else {
                if (isKingInCheck(opponentColor, gameState.board, gameState.enPassantTarget, gameState.activeSpells, gameState.plyCount)) {
                    isCheck = true;
                    const nextPlayerSpells = gameState.spells[opponentColor];
                    if (!hasLegalMoves(opponentColor, gameState.board, gameState.enPassantTarget, gameState.castlingRights, gameState.activeSpells, gameState.plyCount, nextPlayerSpells, gameState.gameTurnNumber)) {
                        isCheckmate = true;
                        gameState.isGameOver = true;
                        const winner = playerWhoMoved.charAt(0).toUpperCase() + playerWhoMoved.slice(1);
                        gameEndMessage = `Checkmate! ${winner} wins!`;
                    }
                } else { 
                    const nextPlayerSpells = gameState.spells[opponentColor];
                    if (!hasLegalMoves(opponentColor, gameState.board, gameState.enPassantTarget, gameState.castlingRights, gameState.activeSpells, gameState.plyCount, nextPlayerSpells, gameState.gameTurnNumber)) {
                        gameState.isGameOver = true;
                        gameEndMessage = "Stalemate! Draw.";
                    }
                }
            }
            
            let finalMoveNotationWithSymbols = gameState.pendingSpellNotation ? gameState.pendingSpellNotation + " " + moveNotation : moveNotation;
            if (isCheckmate) {
                finalMoveNotationWithSymbols += "#";
            } else if (isCheck) {
                finalMoveNotationWithSymbols += "+";
            }
            gameState.pendingSpellNotation = null;

            let next_currentPlayer_state = gameState.currentPlayer; 
            let next_gameTurnNumber_state = gameState.gameTurnNumber;
            let next_whitePlayerTurn_state = gameState.whitePlayerTurn;
            let next_blackPlayerTurn_state = gameState.blackPlayerTurn;

            if (!gameState.isGameOver) {
                if (playerWhoMoved === 'white') { 
                    next_currentPlayer_state = 'black';
                    next_blackPlayerTurn_state = gameState.blackPlayerTurn + 1; 
                } else { 
                    next_currentPlayer_state = 'white';
                    next_whitePlayerTurn_state = gameState.whitePlayerTurn + 1;
                    next_gameTurnNumber_state = gameState.gameTurnNumber + 1;
                }
            }
            
            const stateToSnapshot = deepCopyGameStateForSnapshot(gameState); 
            stateToSnapshot.currentPlayer = next_currentPlayer_state;
            stateToSnapshot.gameTurnNumber = next_gameTurnNumber_state; 
            stateToSnapshot.whitePlayerTurn = next_whitePlayerTurn_state;
            stateToSnapshot.blackPlayerTurn = next_blackPlayerTurn_state;
            stateToSnapshot.plyCount = gameState.plyCount; 
            stateToSnapshot.gameEndMessage = gameState.isGameOver ? gameEndMessage : "";
            gameState.history.push(stateToSnapshot); 
            
            gameState.moveLog.push({ 
                turn: gameState.gameTurnNumber, 
                player: playerWhoMoved, 
                notation: finalMoveNotationWithSymbols, 
                plySnapshotIndex: gameState.plyCount 
            });
            
            gameState.enPassantTarget = null; 
            if (movedPiece?.type.toLowerCase() === 'p' && Math.abs(fromR_param - toR_param) === 2) {
                gameState.enPassantTarget = { r: (fromR_param + toR_param) / 2, c: fromC_param };
            }
            gameState.spellActivationState = null; 
            gameState.spellCaster = null; 
            
            updateNotationDisplay(); 

            if (gameState.isGameOver) {
                updateStatus(gameEndMessage);
            } else { 
                gameState.currentPlayer = next_currentPlayer_state;
                gameState.gameTurnNumber = next_gameTurnNumber_state;
                gameState.whitePlayerTurn = next_whitePlayerTurn_state;
                gameState.blackPlayerTurn = next_blackPlayerTurn_state;
                updateStatus(`${gameState.currentPlayer.charAt(0).toUpperCase() + gameState.currentPlayer.slice(1)}'s turn.` + (isCheck ? " Check!" : ""));
            }
            
            updateSpellControls();
            updateCancelButtonVisibility(); 
            renderBoard(); 
        }
        
        function handleNotationClick(plySnapshotIndex) {
            if (gameState.awaitingPromotion) { 
                updateStatus("Please choose a promotion piece first.");
                return;
            }
            if (plySnapshotIndex < 0 || plySnapshotIndex >= gameState.history.length) {
                console.error("Invalid plySnapshotIndex for history:", plySnapshotIndex);
                return;
            }

            const targetStateSnapshot = gameState.history[plySnapshotIndex];
            if (!targetStateSnapshot) {
                 console.error("No state found in history for index:", plySnapshotIndex);
                 return;
            }
            
            const keysToRestore = [
                'board', 'currentPlayer', 'gameTurnNumber', 'whitePlayerTurn', 
                'blackPlayerTurn', 'plyCount', 'spells', 'activeSpells', 
                'selectedPiece', 'spellMode', 'spellCaster', 'spellActivationState',
                'pendingSpellNotation', 'enPassantTarget', 'castlingRights', 
                'isGameOver', 'gameEndMessage', 'awaitingPromotion' 
            ];

            for (const key of keysToRestore) {
                if (Object.prototype.hasOwnProperty.call(targetStateSnapshot, key)) {
                    if (typeof targetStateSnapshot[key] === 'object' && targetStateSnapshot[key] !== null) {
                        gameState[key] = JSON.parse(JSON.stringify(targetStateSnapshot[key]));
                    } else {
                        gameState[key] = targetStateSnapshot[key];
                    }
                }
            }
            
            gameState.history = gameState.history.slice(0, plySnapshotIndex + 1);
            gameState.moveLog = gameState.moveLog.filter(logEntry => logEntry.plySnapshotIndex <= plySnapshotIndex);

            renderBoard();
            updateSpellControls();
            updateCancelButtonVisibility(); 
            updateNotationDisplay();    

            if (gameState.isGameOver) {
                updateStatus(gameState.gameEndMessage || "Game over at this point.");
            } else if (gameState.awaitingPromotion) {
                 updateStatus(`Choose promotion for pawn at ${String.fromCharCode(97 + gameState.awaitingPromotion.c)}${8 - gameState.awaitingPromotion.r}.`);
            }
            else {
                let statusMsg = `${gameState.currentPlayer.charAt(0).toUpperCase() + gameState.currentPlayer.slice(1)}'s turn.`;
                if (gameState.board && gameState.board.length > 0 && 
                    isKingInCheck(gameState.currentPlayer, gameState.board, gameState.enPassantTarget, gameState.activeSpells, gameState.plyCount)) {
                    statusMsg += " Check!";
                }
                updateStatus(statusMsg);
            }
        }

        function updateNotationDisplay() {
            notationArea.innerHTML = ''; 
            let currentTurnDiv = null;
            let lastTurnNumberProcessed = 0;

            gameState.moveLog.forEach(moveEntry => {
                if (moveEntry.turn !== lastTurnNumberProcessed) {
                    if (currentTurnDiv) {
                        notationArea.appendChild(currentTurnDiv);
                    }
                    currentTurnDiv = document.createElement('div');
                    currentTurnDiv.classList.add('notation-line');
                    
                    const turnNumSpan = document.createElement('span');
                    turnNumSpan.classList.add('notation-turn-number');
                    turnNumSpan.textContent = `${moveEntry.turn}.`;
                    currentTurnDiv.appendChild(turnNumSpan);
                    lastTurnNumberProcessed = moveEntry.turn;
                }

                const moveSpan = document.createElement('span');
                moveSpan.classList.add('notation-move');
                moveSpan.textContent = moveEntry.notation; 
                moveSpan.dataset.plySnapshotIndex = moveEntry.plySnapshotIndex;
                moveSpan.addEventListener('click', () => handleNotationClick(parseInt(moveSpan.dataset.plySnapshotIndex)));
                
                if (currentTurnDiv) { 
                    currentTurnDiv.appendChild(moveSpan);
                    currentTurnDiv.appendChild(document.createTextNode(' ')); 
                }
            });

            if (currentTurnDiv) { 
                notationArea.appendChild(currentTurnDiv);
            }

            if (gameState.moveLog.length === 0) { 
                notationArea.innerHTML = ""; 
            }
            notationArea.scrollTop = notationArea.scrollHeight;
        }

        function updateStatus(message) {
            statusArea.textContent = message;
        }
        
        function updateCancelButtonVisibility() {
            if (gameState.awaitingPromotion) {
                cancelButton.style.display = 'none';
                promotionChoicesDiv.style.display = 'flex';
                return;
            }
            promotionChoicesDiv.style.display = 'none';

            if (!gameState.isGameOver && (gameState.spellMode || gameState.pendingSpellNotation)) {
                cancelButton.style.display = 'block';
            } else {
                cancelButton.style.display = 'none';
            }
        }

        function updateSpellControls() {
            const disableControls = gameState.awaitingPromotion || gameState.isGameOver;

            ['white', 'black'].forEach(player => {
                const spells = gameState.spells[player];
                const currentCastingGameTurnForCheck = gameState.gameTurnNumber;

                const jumpBtn = document.getElementById(`${player}-jump-spell`);
                const jumpCooldownEl = document.getElementById(`${player}-jump-cooldown`);
                document.getElementById(`${player}-jump-count`).textContent = spells.jump;
                
                let jumpDisabled = disableControls || 
                                   player !== gameState.currentPlayer || 
                                   spells.jump === 0 || 
                                   !!gameState.pendingSpellNotation ||
                                   (gameState.spellMode && gameState.spellMode !== 'jump' && gameState.spellCaster === player);
                let jumpCooldownText = spells.jump > 0 ? "Ready" : "No spells left";

                if (spells.jumpLastUsedTurn > 0 && currentCastingGameTurnForCheck < spells.jumpLastUsedTurn + 3) {
                    jumpDisabled = true; 
                    jumpCooldownText = `Cooldown until game turn ${spells.jumpLastUsedTurn + 3}`;
                }
                jumpBtn.disabled = jumpDisabled;
                jumpCooldownEl.textContent = jumpCooldownText;
                jumpBtn.classList.toggle('targeting', !disableControls && gameState.spellMode === 'jump' && gameState.spellCaster === player);

                const freezeBtn = document.getElementById(`${player}-freeze-spell`);
                const freezeCooldownEl = document.getElementById(`${player}-freeze-cooldown`);
                document.getElementById(`${player}-freeze-count`).textContent = spells.freeze;

                let freezeDisabled = disableControls || 
                                     player !== gameState.currentPlayer || 
                                     spells.freeze === 0 || 
                                     !!gameState.pendingSpellNotation ||
                                     (gameState.spellMode && gameState.spellMode !== 'freeze' && gameState.spellCaster === player);
                let freezeCooldownText = spells.freeze > 0 ? "Ready" : "No spells left";

                if (spells.freezeLastUsedTurn > 0 && currentCastingGameTurnForCheck < spells.freezeLastUsedTurn + 3) {
                    freezeDisabled = true;
                    freezeCooldownText = `Cooldown until game turn ${spells.freezeLastUsedTurn + 3}`;
                }
                freezeBtn.disabled = freezeDisabled;
                freezeCooldownEl.textContent = freezeCooldownText;
                freezeBtn.classList.toggle('targeting', !disableControls && gameState.spellMode === 'freeze' && gameState.spellCaster === player);
            });
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const savedDataScript = document.getElementById('savedGameStateData');
            const mainBody = document.body; 

            if (savedDataScript && savedDataScript.textContent.trim() !== "") {
                try {
                    initialGameDataFromSave = JSON.parse(savedDataScript.textContent);
                    mainBody.classList.remove('home-view'); 
                    mainBody.classList.add('game-view');
                } catch (e) {
                    console.error("Error parsing saved game data:", e);
                    initialGameDataFromSave = null;
                }
            }
            resetGame(); 
        });
        
        document.getElementById('white-jump-spell').addEventListener('click', () => activateSpellMode('jump'));
        document.getElementById('white-freeze-spell').addEventListener('click', () => activateSpellMode('freeze'));
        document.getElementById('black-jump-spell').addEventListener('click', () => activateSpellMode('jump'));
        document.getElementById('black-freeze-spell').addEventListener('click', () => activateSpellMode('freeze'));

    </script>
</body>
</html>
