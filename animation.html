You've found another excellent and tricky edge case for "legal moves" in Spell Chess! If a player is in checkmate by conventional moves, but casting a spell (like Jump to enable a capture, or Freeze to disable the attacker or create an escape square) would make them no longer in check *and* allow them to make a subsequent legal move, then it's not actually checkmate.

This requires a more sophisticated `hasLegalMoves` function.

**Refined `hasLegalMoves` Logic:**

The `hasLegalMoves` function, when checking for checkmate, will need to:

1.  **First, check for standard legal moves:** Iterate through all pieces of the current player. For each piece, iterate through all possible destination squares. If `isValidMove` (which includes moving out of check) returns true for any of these, the player has a legal move, and it's not checkmate.
2.  **If no standard legal moves and the king IS in check, then consider spells:**
    *   **Jump Spell:**
        *   If the player has Jump spells available and the cooldown allows:
            *   Iterate through *all* pieces on the board (yours and opponent's) as potential Jump targets.
            *   For each potential Jump target:
                *   Simulate casting Jump on that piece (temporarily make it `isJumpable`).
                *   Now, re-check if the current player's King is still in check.
                *   If casting Jump on *any* piece results in the king *no longer being in check* (even before a move is made, e.g., jumping an interposing piece allows an escape or blocks the check), then it's not checkmate (the player can cast Jump and then must have a legal follow-up move).
                *   More thoroughly: after simulating Jump, iterate through all of the current player's pieces. If any piece *now* has a legal move (using `isValidMove` with the jumped piece active) that results in the king not being in check, then it's not checkmate.
    *   **Freeze Spell:**
        *   If the player has Freeze spells available and the cooldown allows:
            *   Iterate through *all 64 squares* as potential Freeze targets.
            *   For each potential Freeze target:
                *   Simulate casting Freeze on that square (create a temporary `activeSpells` array including this new freeze zone).
                *   Now, re-check if the current player's King is still in check *under these new freeze conditions*.
                *   If casting Freeze on *any* square results in the king *no longer being in check* (e.g., freezing the attacker or a piece that was blocking an escape square which is now open), then it's not checkmate (the player can cast Freeze and then must have a legal follow-up move).
                *   More thoroughly: after simulating Freeze, iterate through all of the current player's pieces. If any piece *now* has a legal move (using `isValidMove` with the new freeze zone active) that results in the king not being in check, then it's not checkmate.

This is computationally more intensive but necessary for the accuracy of checkmate detection with spells.

**Implementation Note:**
The provided rules say "Frozen pieces cannot put a king in check or checkmate." This means if the checking piece itself becomes frozen, the check is immediately lifted. This needs to be reflected in `isKingInCheck` and consequently in `hasLegalMoves`.

Let's refine `isSquareAttacked` and `hasLegalMoves`.

```javascript
// Inside <script id="spell-chess-game-script">

        function isSquareAttacked(targetR, targetC, attackerColor, board, enPassantTarget, activeSpells, currentPly) {
            for (let r_attacker = 0; r_attacker < 8; r_attacker++) { 
                for (let c_attacker = 0; c_attacker < 8; c_attacker++) {
                    const piece = board[r_attacker][c_attacker];
                    if (piece && piece.color === attackerColor) {
                        // IMPORTANT: Check if the attacking piece itself is frozen
                        let isAttackerFrozen = isSquareUnderActiveFreeze(r_attacker, c_attacker, activeSpells, currentPly);
                        if (isAttackerFrozen && piece.type.toLowerCase() !== 'k') { // A frozen king can still "control" squares for opponent's king safety
                            continue; // Frozen non-king pieces do not attack
                        }
                        // If it's a king, it still "attacks" its adjacent squares for the purpose of the opponent king not moving there,
                        // even if the attacking king itself is frozen (it just can't make a move).

                        const pieceType = piece.type.toLowerCase();
                        if (pieceType === 'p') {
                            const attackDR = (attackerColor === 'white') ? -1 : 1; 
                            if (r_attacker + attackDR === targetR && Math.abs(c_attacker - targetC) === 1) return true;
                        } else if (pieceType === 'n') {
                            const drAbs = Math.abs(targetR - r_attacker);
                            const dcAbs = Math.abs(targetC - c_attacker);
                            if ((drAbs === 2 && dcAbs === 1) || (drAbs === 1 && dcAbs === 2)) return true;
                        } else if (pieceType === 'r' || pieceType === 'q') { 
                            if ((r_attacker === targetR || c_attacker === targetC) && isPathClear(r_attacker, c_attacker, targetR, targetC, board)) {
                                return true;
                            }
                        } 
                        if (pieceType === 'b' || pieceType === 'q') { 
                             if (Math.abs(targetR - r_attacker) === Math.abs(targetC - c_attacker) && isPathClear(r_attacker, c_attacker, targetR, targetC, board)) {
                                return true;
                            }
                        }
                        if (pieceType === 'k') {
                            if (Math.abs(targetR - r_attacker) <= 1 && Math.abs(targetC - c_attacker) <= 1) return true;
                        }
                    }
                }
            }
            return false;
        }

        function hasLegalMoves(playerColor, board, enPassantTarget, currentCastlingRights, activeSpells, currentPly, playerSpellsState, playerGameTurnNumber) {
            // 1. Check for standard legal moves
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece.color === playerColor) { 
                        // Ensure the piece itself isn't effectively frozen for this check
                        let isPieceEffectivelyFrozen = isSquareUnderActiveFreeze(r, c, activeSpells, currentPly);
                        if(isPieceEffectivelyFrozen) continue;

                        for (let toR = 0; toR < 8; toR++) {
                            for (let toC = 0; toC < 8; toC++) {
                                if (isValidMove(r, c, toR, toC, board, playerColor, enPassantTarget, currentCastlingRights, activeSpells, currentPly)) {
                                    return true; 
                                }
                            }
                        }
                    }
                }
            }

            // If no standard moves, and king is in check, consider spells
            if (!isKingInCheck(playerColor, board, enPassantTarget, activeSpells, currentPly)) {
                // If not in check and no standard moves, it's stalemate (already handled by above loop returning false)
                return false; 
            }

            // At this point, player is in check and has no standard legal moves.
            // Check if casting a spell can get them out of check AND allow a subsequent legal move.

            // 2. Check Jump Spell
            const canCastJump = playerSpellsState.jump > 0 && (playerSpellsState.jumpLastUsedTurn === 0 || playerGameTurnNumber >= playerSpellsState.jumpLastUsedTurn + 3);
            if (canCastJump) {
                for (let jr = 0; jr < 8; jr++) { // Iterate all squares for jump target
                    for (let jc = 0; jc < 8; jc++) {
                        const targetPieceForJump = board[jr][jc];
                        if (targetPieceForJump) {
                            // Simulate casting Jump
                            const originalIsJumpable = targetPieceForJump.isJumpable;
                            targetPieceForJump.isJumpable = true;
                            
                            // Check if king is NO LONGER in check after jump is applied (even before a move)
                            // Or, more accurately, check if there's a legal move NOW
                            if (!isKingInCheck(playerColor, board, enPassantTarget, activeSpells, currentPly)) { // Path might be cleared
                                // AND there is a legal move for the player
                                for (let r = 0; r < 8; r++) {
                                    for (let c = 0; c < 8; c++) {
                                        const piece = board[r][c];
                                        if (piece && piece.color === playerColor) {
                                            if (isSquareUnderActiveFreeze(r, c, activeSpells, currentPly)) continue;
                                            for (let toR = 0; toR < 8; toR++) {
                                                for (let toC = 0; toC < 8; toC++) {
                                                    if (isValidMove(r, c, toR, toC, board, playerColor, enPassantTarget, currentCastlingRights, activeSpells, currentPly)) {
                                                        targetPieceForJump.isJumpable = originalIsJumpable; // Revert
                                                        return true; // Found a way out
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            targetPieceForJump.isJumpable = originalIsJumpable; // Revert simulation
                        }
                    }
                }
            }

            // 3. Check Freeze Spell
            const canCastFreeze = playerSpellsState.freeze > 0 && (playerSpellsState.freezeLastUsedTurn === 0 || playerGameTurnNumber >= playerSpellsState.freezeLastUsedTurn + 3);
            if (canCastFreeze) {
                for (let fr = 0; fr < 8; fr++) { // Iterate all squares for freeze target
                    for (let fc = 0; fc < 8; fc++) {
                        // Simulate casting Freeze by creating a temporary activeSpells array
                        const tempActiveSpells = JSON.parse(JSON.stringify(activeSpells || [])); 
                        tempActiveSpells.push({
                            type: 'freeze',
                            targetSquare: { r: fr, c: fc },
                            // Freeze spell effect duration for checkmate escape:
                            // It applies for the current turn (where player casts freeze + makes a move) 
                            // AND opponent's next turn. So, for evaluating *this* turn's escape,
                            // the freeze is active for plyCount + 1 (opponent's turn after our move).
                            // The check we are doing is: "If I cast freeze here, then on my move this turn, am I out of check?"
                            // So the freeze is active for the current ply.
                            expiresAtPly: currentPly + 1 // Freeze is active for the current player's move
                        });

                        // If casting freeze makes the king NOT in check
                        if (!isKingInCheck(playerColor, board, enPassantTarget, tempActiveSpells, currentPly)) {
                            // AND there is a legal move for the player under these new freeze conditions
                            for (let r = 0; r < 8; r++) {
                                for (let c = 0; c < 8; c++) {
                                    const piece = board[r][c];
                                    if (piece && piece.color === playerColor) {
                                        // If the piece itself would be frozen by this theoretical freeze, it can't move
                                        if (isSquareUnderActiveFreeze(r, c, tempActiveSpells, currentPly)) continue;
                                        
                                        for (let toR = 0; toR < 8; toR++) {
                                            for (let toC = 0; toC < 8; toC++) {
                                                // isValidMove needs to use tempActiveSpells
                                                if (isValidMove(r, c, toR, toC, board, playerColor, enPassantTarget, currentCastlingRights, tempActiveSpells, currentPly)) {
                                                    return true; // Found a way out
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false; 
        }

```

**Full HTML (with corrected `isSquareAttacked` and `hasLegalMoves`):**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spell Chess</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" integrity="sha512-BNaRQnYJYiPSqHHDb58B0yaPfCu+Wgds8Gp/gU33kqBtgNS4tSPHuGibyoeqMV/TJlSKda6FXzoEyYGjTe+vXA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    
    <style>
        /* Global reset/base */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            box-sizing: border-box;
        }
        *, *:before, *:after {
            box-sizing: inherit;
        }

        /* Styles for home page view */
        body.home-view {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            min-height: 100vh;
            padding: 20px;
        }
        body.home-view #game-content-wrapper {
            display: none;
        }
        body.home-view #announcement-box { 
            display: none;
        }
        body.home-view #home-page-content {
            display: block;
        }

        /* Styles for game view (Desktop First) */
        body.game-view {
            display: flex;
            flex-direction: column; 
            align-items: center; 
            padding: 20px;
            background-color: #fff;
            min-height: 100vh;
        }
        body.game-view #home-page-content {
            display: none;
        }
        body.game-view #game-content-wrapper {
            display: block; 
        }
         body.game-view #announcement-box { 
            display: block; 
            width: 100%;
            max-width: 1100px; 
            margin: 0 auto 20px auto; 
            padding: 15px;
            border: 2px solid #007bff;
            background-color: #e7f3ff;
            border-radius: 8px;
            text-align: center;
            font-size: 0.95em;
            line-height: 1.6;
        }
        #announcement-box h3 {
            margin-top: 0;
            color: #0056b3;
        }
        #announcement-box a {
            color: #0056b3;
            font-weight: bold;
            text-decoration: none;
        }
        #announcement-box a:hover {
            text-decoration: underline;
        }


        #home-page-content h1 {
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        #start-game-button {
            padding: 15px 30px;
            font-size: 1.2em;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            margin-bottom: 5px;
        }
        #start-game-button:hover {
            background-color: #45a049;
        }

        .game-container {
            display: flex;
            flex-wrap: wrap; 
            gap: 20px;
            align-items: flex-start;
            width: 100%;
            margin: 0 auto;
        }

        .main-game-area { 
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 480px; 
            flex-shrink: 0;
        }

        .status-area {
            padding: 10px;
            border: 1px solid #ccc;
            background-color: #e9ecef;
            min-height: 50px;
            width: 100%; 
            text-align: center; 
        }
        .rules-area {
            padding: 10px;
            border: 1px solid #ccc;
            background-color: #f8f9fa;
            width: 100%;
            margin-top: 10px; 
            font-size: 0.9em;
            line-height: 1.5;
        }
        .rules-area h4 {
            margin-top: 0;
            color: #333;
        }
        .rules-area ul {
            padding-left: 20px;
            margin-bottom: 0;
        }
        .rules-area li {
            margin-bottom: 5px;
        }

        .chessboard {
            width: 480px;
            height: 480px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 2px solid #333;
        }
        .square {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            cursor: pointer;
            user-select: none;
            position: relative;
        }
        .square.light { background-color: #f0d9b5; }
        .square.dark { background-color: #b58863; }
        .square.selected { background-color: #6a994e; }

        .square.valid-move-hint::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(167, 201, 87, 0.5);
            box-shadow: inset 0 0 0 2px #6a994e;
            z-index: 1;
        }
        .square.active-freeze-zone {
            box-shadow: inset 0 0 0 1000px rgba(173, 216, 230, 0.35);
        }
        .square.jumpable-on-square {
            box-shadow: inset 0 0 0 1000px rgba(255, 255, 0, 0.25),
                        inset 0 0 0 3px #DAA520;
        }
        .square.freeze-outline-top { border-top: 3px solid #007bff; }
        .square.freeze-outline-bottom { border-bottom: 3px solid #007bff; }
        .square.freeze-outline-left { border-left: 3px solid #007bff; }
        .square.freeze-outline-right { border-right: 3px solid #007bff; }

        .square-freeze-emoji {
            position: absolute;
            top: 1px;
            right: 1px;
            font-size: 15px;
            opacity: 0.9;
            z-index: 1;
            pointer-events: none;
        }
        .piece {
            position: relative;
            z-index: 2;
        }
        .chessboard.colored-pieces .piece.white-piece-alternative {
            color: white; 
            text-shadow: -1px -1px 0 #555, 1px -1px 0 #555, -1px 1px 0 #555, 1px 1px 0 #555;
        }

        .controls {
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex-shrink: 0;
        }
        .player-info { padding: 10px; border: 1px solid #ccc; border-radius: 5px; }
        .player-info h3 { margin-top: 0; }
        .spell-button, .reset-button, .promotion-button { 
            padding: 8px 12px;
            cursor: pointer;
            border: 1px solid #555;
            border-radius: 4px;
            background-color: #f0f0f0;
            width: 100%;
        }
        .promotion-button {
            margin-bottom: 5px;
        }
        .spell-button:disabled { cursor: not-allowed; background-color: #ccc; color: #777; }
        .spell-button.targeting { background-color: #add8e6; }

        .notation-area {
            padding: 10px;
            border: 1px solid #ccc;
            height: 480px; 
            width: 360px;
            overflow-y: auto;
            background-color: #f8f9fa;
            flex-shrink: 0;
        }
        .notation-area .notation-line {
            margin-bottom: 2px;
        }
        .notation-area .notation-turn-number {
            font-weight: bold;
            margin-right: 2px; 
        }
        .notation-area .notation-move {
            cursor: pointer;
            text-decoration: underline;
            color: #0056b3;
            margin-right: 5px;
        }
        .notation-area .notation-move:hover {
            color: #007bff;
        }

        #promotion-choices {
            margin-top: 10px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
         #gif-output-area { 
            margin-top: 20px;
            text-align: center;
            width: 100%; 
        }


        /* --- MOBILE STYLES --- */
        @media (max-width: 768px) {
            body.game-view {
                padding: 10px; 
            }
            #announcement-box {
                max-width: 95vw; 
                font-size: 0.85em;
            }
            .game-container {
                flex-direction: column; 
                align-items: center; 
                gap: 15px;
                flex-wrap: nowrap; 
            }
            .main-game-area { 
                 width: 90vw;
                 max-width: 400px; 
                 order: 1; 
                 gap: 10px;
            }
            .chessboard {
                width: 100%; 
                height: auto; 
                aspect-ratio: 1 / 1; 
                max-width: none; 
                max-height: none;
            }
            .status-area {
                 width: 100%; 
                 max-width: none; 
                 text-align: center;
            }
            .rules-area {
                font-size: 0.8em;
            }
            .square {
                font-size: 7vw;
            }
            @media (min-width: 450px) and (max-width: 768px) {
                .square {
                    font-size: 32px;
                }
            }
            .controls {
                order: 2; 
                width: 90vw;
                max-width: 480px;
            }
            .player-info {
                display: flex;
                flex-direction: column;
                align-items: stretch;
            }
            .player-info h3 {
                text-align: center;
            }
             .player-info .spell-button, .player-info small {
                width: auto;
                margin-left: auto;
                margin-right: auto;
                text-align: center;
            }
             .player-info small {
                margin-bottom: 5px;
                display: block;
             }
            .notation-area {
                order: 3; 
                width: 90vw;
                max-width: 480px;
                height: 150px;
            }
             #promotion-choices {
                order: -1;
            }
            #gif-output-area {
                order: 4; 
                width: 90vw;
                max-width: 480px;
            }
        }
        @media (max-width: 400px) {
            .square {
                font-size: 28px;
            }
            .player-info h3 {
                font-size: 1em;
            }
            .spell-button, .reset-button, .promotion-button {
                padding: 6px 10px;
                font-size: 0.9em;
            }
            .main-game-area { 
                width: 95vw; 
            }
            .controls, .notation-area, #gif-output-area {
                 width: 95vw;
            }
        }
    </style>
</head>
<body class="home-view"> 

    <div id="home-page-content">
        <h1>Spell Chess</h1>
        <button id="start-game-button">Two Player Game</button>
    </div>

    <div id="announcement-box">
        <h3><a href="https://www.chess.com/club/spell-chess-team-game-starting-2025-06-01" target="_blank">Spell Chess Team Game</a></h3>
        <p>
            Start Date: June 1, 2025<br>
            Time Control: 24 Hours Per Move<br>
            Join the club for the <a href="https://www.chess.com/club/white-team-spell-chess-game-2025-06-01" target="_blank">White Team</a> or <a href="https://www.chess.com/club/black-team-spell-chess-game-2025-06-01" target="_blank">Black Team</a> to participate!<br>
            This page is kept up to date with the current position by <a href="https://www.chess.com/member/LongTermFuture" target="_blank">LongTermFuture</a>.
        </p>
    </div>

    <div id="game-content-wrapper">
        <div class="game-container">
            <div class="main-game-area">
                <div id="chessboard" class="chessboard"></div> 
                <div id="status-area" class="status-area">White's turn.</div>
                <div id="rules-area" class="rules-area">
                    <h4>Spell Chess Rules:</h4>
                    <ul>
                        <li>Standard chess rules apply.</li>
                        <li>Each player starts with two Jump spells and five Freeze spells.</li>
                        <li>A player may cast a spell before making their move.</li>
                        <li><strong>Jump Spell:</strong> Target any piece. For your current move and your opponent's next move, that piece is jumpable by other pieces as if it is not there.</li>
                        <li><strong>Freeze Spell:</strong> Target any square. All pieces in a 3x3 area around the target square are frozen and cannot move on your turn or your opponent's next turn. Frozen pieces cannot put a king in check or checkmate.</li>
                        <li>Spells have a 3-turn cooldown before they can be used again.</li>
                        <li>Checkmate or capture your opponent's king to win.</li>
                    </ul>
                </div>
            </div>
            <div class="controls">
                <div id="white-player-info" class="player-info">
                    <h3>White</h3>
                    <button id="white-jump-spell" class="spell-button">Cast Jump (<span id="white-jump-count">2</span>)</button>
                    <small id="white-jump-cooldown"></small>
                    <button id="white-freeze-spell" class="spell-button">Cast Freeze (<span id="white-freeze-count">5</span>)</button>
                    <small id="white-freeze-cooldown"></small>
                </div>
                <div id="black-player-info" class="player-info">
                    <h3>Black</h3>
                    <button id="black-jump-spell" class="spell-button">Cast Jump (<span id="black-jump-count">2</span>)</button>
                    <small id="black-jump-cooldown"></small>
                    <button id="black-freeze-spell" class="spell-button">Cast Freeze (<span id="black-freeze-count">5</span>)</button>
                    <small id="black-freeze-cooldown"></small>
                </div>
                
                <button id="toggle-pieces-button" class="reset-button">Use Standard Pieces</button>
                <button id="download-game-button" class="reset-button">Download Game</button>
                <button id="download-gif-button" class="reset-button">Download GIF Frames</button>
                <button id="reset-game-button" class="reset-button">Reset Game</button>
                <button id="go-home-button" class="reset-button">Home</button>
                
                <div id="promotion-choices" style="display:none;">
                    <button class="promotion-button" data-promote="Q">Promote to Queen</button>
                    <button class="promotion-button" data-promote="R">Promote to Rook</button>
                    <button class="promotion-button" data-promote="B">Promote to Bishop</button>
                    <button class="promotion-button" data-promote="N">Promote to Knight</button>
                </div>
                <button id="cancel-button" class="reset-button" style="display:none; margin-top:10px; width:100%;">Cancel</button>
            </div>
            <div id="notation-area" class="notation-area"></div>
        </div>
        <div id="gif-output-area">
            <!-- Content here if needed -->
        </div>
    </div>

    <script id="savedGameStateData" type="application/json"></script>

    <script id="home-page-script">
        const startGameButton = document.getElementById('start-game-button');
        const goHomeButton = document.getElementById('go-home-button');
        const mainBody = document.body;

        startGameButton.addEventListener('click', function() {
            mainBody.classList.remove('home-view');
            mainBody.classList.add('game-view');
            if (typeof resetGame === 'function') { 
                resetGame(true);
            }
        });

        goHomeButton.addEventListener('click', function() {
            mainBody.classList.remove('game-view');
            mainBody.classList.add('home-view');
        });
    </script>

    <script id="spell-chess-game-script">
        const PIECES = {
            'P': '♙', 'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔',
            'p': '♟', 'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚'
        };
        let useStandardPieces = false; 

        const initialBoardSetup = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];

        let gameState;
        let initialGameDataFromSave = null;

        const chessboardDiv = document.getElementById('chessboard');
        const statusArea = document.getElementById('status-area');
        const notationArea = document.getElementById('notation-area');
        const cancelButton = document.getElementById('cancel-button'); 
        const promotionChoicesDiv = document.getElementById('promotion-choices');
        const downloadGameButton = document.getElementById('download-game-button');
        const downloadGifButton = document.getElementById('download-gif-button');
        const togglePiecesButton = document.getElementById('toggle-pieces-button');


        function deepCopyGameStateForSnapshot(sourceState) { 
            if (!sourceState) return null;
            const target = {};
            for (const key in sourceState) {
                if (Object.prototype.hasOwnProperty.call(sourceState, key)) {
                    if (key === 'history' || key === 'moveLog') { 
                        continue; 
                    }
                    const value = sourceState[key];
                    if (typeof value === 'object' && value !== null) {
                        target[key] = JSON.parse(JSON.stringify(value));
                    } else {
                        target[key] = value;
                    }
                }
            }
            return target;
        }
        
        function deepCopyFullState(sourceState) {
            return JSON.parse(JSON.stringify(sourceState));
        }

        function initializeGameState() {
            gameState = {
                board: [],
                currentPlayer: 'white',
                gameTurnNumber: 1,
                whitePlayerTurn: 1, 
                blackPlayerTurn: 1, 
                plyCount: 0, 
                spells: {
                    white: { jump: 2, freeze: 5, jumpLastUsedTurn: 0, freezeLastUsedTurn: 0 },
                    black: { jump: 2, freeze: 5, jumpLastUsedTurn: 0, freezeLastUsedTurn: 0 }
                },
                activeSpells: [],
                selectedPiece: null,
                spellMode: null,
                spellCaster: null,
                spellActivationState: null,
                pendingSpellNotation: null,
                moveLog: [], 
                enPassantTarget: null,
                castlingRights: {
                    white: { K: true, Q: true },
                    black: { k: true, q: true }
                },
                isGameOver: false,
                gameEndMessage: "", 
                awaitingPromotion: null,
                history: [],
                useStandardPieces: false 
            };
        }

        function initializeBoardState() {
            gameState.board = initialBoardSetup.map((row, r) =>
                row.map((pieceType, c) => {
                    if (!pieceType) return null;
                    const color = (pieceType === pieceType.toUpperCase()) ? 'white' : 'black';
                    return {
                        type: pieceType,
                        color: color,
                        id: `piece-${r}-${c}-${Date.now()}`, 
                        isFrozen: false,
                        isJumpable: false,
                        hasMoved: false
                    };
                })
            );
        }

        function resetGame(forceNewGame = false) {
            if (!forceNewGame && initialGameDataFromSave) {
                gameState = deepCopyFullState(initialGameDataFromSave); 
                useStandardPieces = gameState.useStandardPieces === undefined ? false : gameState.useStandardPieces; 
                initialGameDataFromSave = null; 
                console.log("Game loaded from saved state.");
                document.body.classList.remove('home-view');
                document.body.classList.add('game-view');
            } else {
                initializeGameState();
                initializeBoardState();
                const initialSnapshot = deepCopyGameStateForSnapshot(gameState); 
                gameState.history.push(initialSnapshot);
                console.log("New game started.");
            }

            promotionChoicesDiv.style.display = 'none';
            applyPieceStyle();
            updateSpellControls();
            updateCancelButtonVisibility();
            updateNotationDisplay();

            if (gameState.isGameOver) {
                updateStatus(gameState.gameEndMessage || "Game over.");
            } else if (gameState.awaitingPromotion) {
                updateStatus(`Choose promotion for pawn at ${String.fromCharCode(97 + gameState.awaitingPromotion.c)}${8 - gameState.awaitingPromotion.r}.`);
            } else {
                let statusMsg = `${gameState.currentPlayer.charAt(0).toUpperCase() + gameState.currentPlayer.slice(1)}'s turn.`;
                 if (gameState.board && gameState.board.length > 0 && 
                    isKingInCheck(gameState.currentPlayer, gameState.board, gameState.enPassantTarget, gameState.activeSpells, gameState.plyCount)) {
                    statusMsg += " Check!";
                }
                updateStatus(statusMsg);
            }
        }
        
        function applyPieceStyle() {
            if (useStandardPieces) {
                chessboardDiv.classList.remove('colored-pieces');
                togglePiecesButton.textContent = "Use Colored Pieces";
            } else {
                chessboardDiv.classList.add('colored-pieces');
                togglePiecesButton.textContent = "Use Standard Pieces";
            }
            if(gameState && gameState.board && gameState.board.length > 0) { 
               renderBoard();
            }
        }
        
        togglePiecesButton.addEventListener('click', () => {
            useStandardPieces = !useStandardPieces;
            gameState.useStandardPieces = useStandardPieces; 
            applyPieceStyle();
        });


        document.getElementById('reset-game-button').addEventListener('click', () => resetGame(true)); 
        cancelButton.addEventListener('click', handleCancelAction); 

        promotionChoicesDiv.addEventListener('click', function(event) {
            if (event.target.classList.contains('promotion-button') && gameState.awaitingPromotion) {
                const chosenPieceType = event.target.dataset.promote;
                const { r, c, color, originalMoveNotation, movingPiece, fromR, fromC } = gameState.awaitingPromotion;

                gameState.board[r][c].type = (color === 'white') ? chosenPieceType.toUpperCase() : chosenPieceType.toLowerCase();
                
                const finalMoveNotation = originalMoveNotation + "=" + chosenPieceType.toUpperCase(); 

                gameState.awaitingPromotion = null;
                promotionChoicesDiv.style.display = 'none';
                updateCancelButtonVisibility(); 
                
                renderBoard(); 
                endTurn(finalMoveNotation, movingPiece, fromR, r, fromC);
            }
        });

        downloadGameButton.addEventListener('click', () => { 
            if (gameState.awaitingPromotion) {
                alert("Cannot download game while awaiting pawn promotion.");
                return;
            }
            gameState.useStandardPieces = useStandardPieces; 
            const stateToSave = deepCopyFullState(gameState);
            const serializedState = JSON.stringify(stateToSave);

            const clonedDocument = document.cloneNode(true);
            
            let existingSavedScriptInClone = clonedDocument.getElementById('savedGameStateData');
            if (existingSavedScriptInClone) {
                existingSavedScriptInClone.textContent = serializedState; 
            } else { 
                const scriptTag = clonedDocument.createElement('script');
                scriptTag.id = 'savedGameStateData';
                scriptTag.type = 'application/json'; 
                scriptTag.textContent = serializedState;
                clonedDocument.head.appendChild(scriptTag);
            }

            const fullHtmlContent = '<!DOCTYPE html>\n' + clonedDocument.documentElement.outerHTML;
            const blob = new Blob([fullHtmlContent], { type: 'text/html;charset=utf-8' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            
            let filename = "Spell_chess.html"; 
            if (gameState.moveLog.length > 0) {
                const lastFullTurnEntryIndex = gameState.moveLog.length - 1;
                let turnNumberForFile = gameState.moveLog[lastFullTurnEntryIndex].turn;
                let whiteMoveForFile = "";
                let blackMoveForFile = "";

                for(let i = lastFullTurnEntryIndex; i >=0; i--){
                    if(gameState.moveLog[i].turn === turnNumberForFile && gameState.moveLog[i].player === 'white'){
                        whiteMoveForFile = gameState.moveLog[i].notation.replace(/[#+=\s@]/g, '');
                        break;
                    }
                     if(gameState.moveLog[i].turn < turnNumberForFile) break;
                }
                for(let i = lastFullTurnEntryIndex; i >=0; i--){
                     if(gameState.moveLog[i].turn === turnNumberForFile && gameState.moveLog[i].player === 'black'){
                        blackMoveForFile = gameState.moveLog[i].notation.replace(/[#+=\s@]/g, '');
                        break;
                    }
                    if(gameState.moveLog[i].turn < turnNumberForFile) break;
                }
                
                filename = `${turnNumberForFile}`;
                if (whiteMoveForFile) {
                    filename += whiteMoveForFile;
                }
                if (blackMoveForFile) {
                     filename += (whiteMoveForFile ? "_" : "") + blackMoveForFile;
                }
                filename += ".html";
            }
            link.download = filename;

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
        });

        downloadGifButton.addEventListener('click', async () => {
            if (gameState.awaitingPromotion) {
                alert("Cannot generate GIF frames while awaiting pawn promotion.");
                return;
            }
            if (gameState.history.length <= 1 && gameState.plyCount === 0) { 
                alert("No moves made to generate GIF frames.");
                return;
            }

            updateStatus("Preparing to download GIF frames... Please allow multiple downloads if prompted.");
            downloadGifButton.disabled = true;
            document.querySelectorAll('.controls button:not(#download-gif-button)').forEach(btn => btn.disabled = true);
            
            window.open('https://ezgif.com/maker', '_blank');

            const originalGameStateSnapshotJSON = JSON.stringify(gameState);
            const originalSelectedPieceJSON = gameState.selectedPiece ? JSON.stringify(gameState.selectedPiece) : null;
            const actualCurrentPlyCount = gameState.plyCount; 
            const originalUseStandardPieces = useStandardPieces;
            
            const tempGameStateForRender = {}; 

            try {
                for (let i = 0; i < gameState.history.length; i++) {
                    const historicalStateSnapshot = gameState.history[i];
                    
                    for (const key in historicalStateSnapshot) {
                        if (Object.prototype.hasOwnProperty.call(historicalStateSnapshot, key)) {
                             if (typeof historicalStateSnapshot[key] === 'object' && historicalStateSnapshot[key] !== null) {
                                tempGameStateForRender[key] = JSON.parse(JSON.stringify(historicalStateSnapshot[key]));
                            } else {
                                tempGameStateForRender[key] = historicalStateSnapshot[key];
                            }
                        }
                    }
                    
                    gameState.board = tempGameStateForRender.board; 
                    gameState.activeSpells = tempGameStateForRender.activeSpells || []; 
                    gameState.plyCount = tempGameStateForRender.plyCount; 
                    gameState.selectedPiece = null; 
                    useStandardPieces = tempGameStateForRender.useStandardPieces === undefined ? originalUseStandardPieces : tempGameStateForRender.useStandardPieces;
                    applyPieceStyle(); 
                    
                    updateStatus(`Downloading frame ${i + 1} of ${gameState.history.length}...`);
                    await new Promise(resolve => setTimeout(resolve, 50)); 

                    const canvas = await html2canvas(chessboardDiv, {
                        allowTaint: true, 
                        useCORS: true, 
                        logging: false,
                        width: chessboardDiv.offsetWidth,
                        height: chessboardDiv.offsetHeight,
                        backgroundColor: null 
                    });
                    
                    const link = document.createElement('a');
                    link.download = `spell_chess_frame_${String(i).padStart(3, '0')}.png`;
                    link.href = canvas.toDataURL('image/png');
                    document.body.appendChild(link); 
                    link.click();
                    document.body.removeChild(link); 
                    await new Promise(resolve => setTimeout(resolve, 250)); 
                }
                updateStatus("All GIF frames downloaded. You can assemble them at ezgif.com.");

            } catch (error) {
                console.error("Error during GIF frame download process:", error);
                updateStatus("GIF frame download failed.");
            } finally {
                const originalGameStateRestored = JSON.parse(originalGameStateSnapshotJSON);
                for (const key in originalGameStateRestored) {
                    if (Object.prototype.hasOwnProperty.call(originalGameStateRestored, key)) {
                         if (typeof originalGameStateRestored[key] === 'object' && originalGameStateRestored[key] !== null) {
                            gameState[key] = JSON.parse(JSON.stringify(originalGameStateRestored[key]));
                        } else {
                            gameState[key] = originalGameStateRestored[key];
                        }
                    }
                }
                gameState.selectedPiece = originalSelectedPieceJSON ? JSON.parse(originalSelectedPieceJSON) : null;
                gameState.plyCount = actualCurrentPlyCount; 
                useStandardPieces = originalUseStandardPieces; 
                applyPieceStyle(); 

                updateSpellControls(); 
                updateCancelButtonVisibility();
                downloadGifButton.disabled = false;
                 document.querySelectorAll('.controls button').forEach(btn => {
                    const isDisabledByGameLogic = (gameState.isGameOver || gameState.awaitingPromotion);
                     if (btn.id === 'download-gif-button') { // Ensure GIF button itself is handled
                        btn.disabled = isDisabledByGameLogic;
                     } else if (btn.id === 'go-home-button' || btn.id === 'reset-game-button' || btn.id === 'download-game-button' || btn.id === 'toggle-pieces-button') {
                        btn.disabled = false; 
                    } else if (btn.id.includes('-spell') || btn.id === 'cancel-button') { 
                        btn.disabled = isDisabledByGameLogic;
                    }
                });
                updateSpellControls(); // Refresh spell buttons after other controls are set
                
                if (gameState.isGameOver) {
                    updateStatus(gameState.gameEndMessage || "Game over.");
                } else if (gameState.awaitingPromotion) {
                    updateStatus(`Choose promotion for pawn at ${String.fromCharCode(97 + gameState.awaitingPromotion.c)}${8 - gameState.awaitingPromotion.r}.`);
                } else {
                    let statusMsg = `${gameState.currentPlayer.charAt(0).toUpperCase() + gameState.currentPlayer.slice(1)}'s turn.`;
                    if (isKingInCheck(gameState.currentPlayer, gameState.board, gameState.enPassantTarget, gameState.activeSpells, gameState.plyCount)) {
                        statusMsg += " Check!";
                    }
                    updateStatus(statusMsg);
                }
            }
        });

        function renderBoard() {
            chessboardDiv.innerHTML = '';
            if (!useStandardPieces) {
                chessboardDiv.classList.add('colored-pieces');
            } else {
                chessboardDiv.classList.remove('colored-pieces');
            }

            const validMovesForSelected = gameState.selectedPiece ? getValidMovesForPiece(gameState.selectedPiece.r, gameState.selectedPiece.c) : [];

            gameState.board.forEach((row, r_idx) => {
                row.forEach((piece, c_idx) => {
                    const square = document.createElement('div');
                    square.classList.add('square');
                    square.classList.add((r_idx + c_idx) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.r = r_idx;
                    square.dataset.c = c_idx;

                    square.classList.remove('active-freeze-zone', 'jumpable-on-square',
                                            'freeze-outline-top', 'freeze-outline-bottom',
                                            'freeze-outline-left', 'freeze-outline-right');

                    if (isSquareUnderActiveFreeze(r_idx, c_idx, gameState.activeSpells, gameState.plyCount)) {
                        square.classList.add('active-freeze-zone');
                        const freezeEmojiSpan = document.createElement('span');
                        freezeEmojiSpan.classList.add('square-freeze-emoji');
                        freezeEmojiSpan.textContent = '❄️';
                        square.appendChild(freezeEmojiSpan);
                    } else if (piece && piece.isJumpable) {
                        square.classList.add('jumpable-on-square');
                    }
                     gameState.activeSpells.forEach(spell => {
                        if (spell.type === 'freeze' && gameState.plyCount < spell.expiresAtPly) {
                            const spellCenterR = spell.targetSquare.r;
                            const spellCenterC = spell.targetSquare.c;
                            const minEffectR = Math.max(0, spellCenterR - 1);
                            const maxEffectR = Math.min(7, spellCenterR + 1);
                            const minEffectC = Math.max(0, spellCenterC - 1);
                            const maxEffectC = Math.min(7, spellCenterC + 1);
                            if (r_idx >= minEffectR && r_idx <= maxEffectR && c_idx >= minEffectC && c_idx <= maxEffectC) {
                                if (r_idx === minEffectR) square.classList.add('freeze-outline-top');
                                if (r_idx === maxEffectR) square.classList.add('freeze-outline-bottom');
                                if (c_idx === minEffectC) square.classList.add('freeze-outline-left');
                                if (c_idx === maxEffectC) square.classList.add('freeze-outline-right');
                            }
                        }
                    });


                    if (piece) {
                        const pieceSpan = document.createElement('span');
                        pieceSpan.classList.add('piece');
                        
                        let displayPieceType = piece.type;
                        if (!useStandardPieces && piece.color === 'white') {
                            displayPieceType = piece.type.toLowerCase(); 
                            pieceSpan.classList.add('white-piece-alternative'); 
                        } else { 
                            pieceSpan.classList.remove('white-piece-alternative');
                        }

                        pieceSpan.textContent = PIECES[displayPieceType];
                        pieceSpan.dataset.pieceId = piece.id;
                        square.appendChild(pieceSpan);
                    }

                    if (gameState.selectedPiece && gameState.selectedPiece.r === r_idx && gameState.selectedPiece.c === c_idx) {
                        square.classList.add('selected');
                    }

                    if (validMovesForSelected.some(move => move.toR === r_idx && move.toC === c_idx)) {
                       square.classList.add('valid-move-hint');
                    }

                    square.addEventListener('click', () => onSquareClick(r_idx, c_idx));
                    chessboardDiv.appendChild(square);
                });
            });
        }

        function isSquareUnderActiveFreeze(sqR, sqC, activeSpells, currentPly) {
            for (const spell of activeSpells) {
                if (spell.type === 'freeze' && currentPly < spell.expiresAtPly) {
                    const centerR = spell.targetSquare.r;
                    const centerC = spell.targetSquare.c;
                    if (Math.abs(sqR - centerR) <= 1 && Math.abs(sqC - centerC) <= 1) {
                        if (sqR >= Math.max(0, centerR -1) && sqR <= Math.min(7, centerR + 1) &&
                            sqC >= Math.max(0, centerC -1) && sqC <= Math.min(7, centerC + 1)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function onSquareClick(r_clicked, c_clicked) {
            if (gameState.isGameOver || gameState.awaitingPromotion) { 
                if (gameState.awaitingPromotion) updateStatus("Choose promotion piece.");
                else updateStatus("Game is over. Please reset to play again.");
                return;
            }

            const pieceAtClickedSquare = gameState.board[r_clicked][c_clicked];

            if (gameState.spellMode) {
                handleSpellTargeting(r_clicked, c_clicked);
                return;
            }

            if (gameState.selectedPiece) {
                if (gameState.selectedPiece.r === r_clicked && gameState.selectedPiece.c === c_clicked) {
                    gameState.selectedPiece = null;
                    renderBoard();
                    updateCancelButtonVisibility(); 
                    return;
                }

                const { r: fromR, c: fromC, piece: movingPiece } = gameState.selectedPiece;

                if (isValidMove(fromR, fromC, r_clicked, c_clicked, gameState.board, gameState.currentPlayer, gameState.enPassantTarget, gameState.castlingRights, gameState.activeSpells, gameState.plyCount)) {
                    let capturedPiece = gameState.board[r_clicked][c_clicked];
                    let moveNotation = "";
                    let isEnPassantCapture = false;
                    let isCastle = false;

                    if (movingPiece.type.toLowerCase() === 'k' && Math.abs(fromC - c_clicked) === 2) {
                        isCastle = true;
                        const isKingside = c_clicked > fromC;
                        moveNotation = isKingside ? "O-O" : "O-O-O";

                        gameState.board[r_clicked][c_clicked] = movingPiece;
                        gameState.board[fromR][fromC] = null;
                        movingPiece.hasMoved = true;

                        const rookFromC = isKingside ? 7 : 0;
                        const rookToC = isKingside ? c_clicked - 1 : c_clicked + 1;
                        const rook = gameState.board[fromR][rookFromC];
                        if (rook) {
                            gameState.board[fromR][rookToC] = rook;
                            gameState.board[fromR][rookFromC] = null;
                            rook.hasMoved = true;
                        }
                        if (gameState.currentPlayer === 'white') {
                            gameState.castlingRights.white.K = false;
                            gameState.castlingRights.white.Q = false;
                        } else {
                            gameState.castlingRights.black.k = false;
                            gameState.castlingRights.black.q = false;
                        }
                    } else {
                        if (movingPiece.type.toLowerCase() === 'p' &&
                            Math.abs(fromC - c_clicked) === 1 &&
                            !gameState.board[r_clicked][c_clicked] &&
                            gameState.enPassantTarget &&
                            r_clicked === gameState.enPassantTarget.r &&
                            c_clicked === gameState.enPassantTarget.c) {

                            isEnPassantCapture = true;
                            const epCapturedPawnActualR = fromR;
                            const epCapturedPawnActualC = c_clicked;
                            capturedPiece = gameState.board[epCapturedPawnActualR][epCapturedPawnActualC];
                            gameState.board[epCapturedPawnActualR][epCapturedPawnActualC] = null;
                            moveNotation = generateMoveNotation(movingPiece, fromR, fromC, r_clicked, c_clicked, capturedPiece, true);
                        } else {
                             moveNotation = generateMoveNotation(movingPiece, fromR, fromC, r_clicked, c_clicked, capturedPiece);
                        }
                        
                        gameState.board[r_clicked][c_clicked] = movingPiece;
                        movingPiece.hasMoved = true;
                        gameState.board[fromR][fromC] = null;

                        if (movingPiece.type.toLowerCase() === 'k') {
                            if (movingPiece.color === 'white') {
                                gameState.castlingRights.white.K = false;
                                gameState.castlingRights.white.Q = false;
                            } else {
                                gameState.castlingRights.black.k = false;
                                gameState.castlingRights.black.q = false;
                            }
                        } else if (movingPiece.type.toLowerCase() === 'r') {
                            if (movingPiece.color === 'white') {
                                if (fromR === 7 && fromC === 0) gameState.castlingRights.white.Q = false;
                                if (fromR === 7 && fromC === 7) gameState.castlingRights.white.K = false;
                            } else {
                                if (fromR === 0 && fromC === 0) gameState.castlingRights.black.q = false;
                                if (fromR === 0 && fromC === 7) gameState.castlingRights.black.k = false;
                            }
                        }
                    }

                    gameState.selectedPiece = null; 

                    if (!isCastle && movingPiece.type.toLowerCase() === 'p' &&
                        ((movingPiece.color === 'white' && r_clicked === 0) || (movingPiece.color === 'black' && r_clicked === 7))) {
                        
                        gameState.awaitingPromotion = {
                            r: r_clicked,
                            c: c_clicked,
                            color: movingPiece.color,
                            originalMoveNotation: moveNotation,
                            movingPiece: gameState.board[r_clicked][c_clicked], 
                            fromR: fromR, 
                            fromC: fromC  
                        };
                        promotionChoicesDiv.style.display = 'flex'; 
                        cancelButton.style.display = 'none'; 
                        updateStatus(`Choose promotion for pawn at ${String.fromCharCode(97 + c_clicked)}${8 - r_clicked}.`);
                        renderBoard(); 
                        return; 
                    }
                    
                    const pieceToEndTurnWith = gameState.board[r_clicked][c_clicked] || movingPiece; 
                    endTurn(moveNotation, pieceToEndTurnWith, fromR, r_clicked, fromC);
                } else if (pieceAtClickedSquare && pieceAtClickedSquare.color === gameState.currentPlayer) {
                    let effectivelyFrozenNewSelection = pieceAtClickedSquare.isFrozen || isSquareUnderActiveFreeze(r_clicked, c_clicked, gameState.activeSpells, gameState.plyCount);
                    if (effectivelyFrozenNewSelection) {
                        updateStatus("This piece is frozen or on a frozen square and cannot move.");
                        return; 
                    }
                    gameState.selectedPiece = { r: r_clicked, c: c_clicked, piece: pieceAtClickedSquare };
                    renderBoard();
                } else { 
                    updateStatus("Invalid move or empty square. Try again.");
                    gameState.selectedPiece = null; 
                    renderBoard();
                }
            } else { 
                if (pieceAtClickedSquare && pieceAtClickedSquare.color === gameState.currentPlayer) {
                    let effectivelyFrozenInitialSelection = pieceAtClickedSquare.isFrozen || isSquareUnderActiveFreeze(r_clicked, c_clicked, gameState.activeSpells, gameState.plyCount);
                    if (effectivelyFrozenInitialSelection) {
                        updateStatus("This piece is frozen or on a frozen square and cannot move.");
                        return;
                    }
                    gameState.selectedPiece = { r: r_clicked, c: c_clicked, piece: pieceAtClickedSquare };
                    renderBoard();
                }
            }
            updateCancelButtonVisibility(); 
        }

        function isPathClear(fromR, fromC, toR, toC, board) {
            const dr = Math.sign(toR - fromR);
            const dc = Math.sign(toC - fromC);
            let r = fromR + dr;
            let c = fromC + dc;

            while (r !== toR || c !== toC) {
                if (r < 0 || r >= 8 || c < 0 || c >= 8) return false; 
                const pieceOnPath = board[r][c];
                if (pieceOnPath && !pieceOnPath.isJumpable) { 
                    return false; 
                }
                r += dr;
                c += dc;
            }
            return true;
        }

        function isSquareAttacked(targetR, targetC, attackerColor, board, enPassantTarget, activeSpells, currentPly) {
            for (let r_attacker = 0; r_attacker < 8; r_attacker++) { 
                for (let c_attacker = 0; c_attacker < 8; c_attacker++) {
                    const piece = board[r_attacker][c_attacker];
                    if (piece && piece.color === attackerColor) {
                        let isAttackerFrozen = isSquareUnderActiveFreeze(r_attacker, c_attacker, activeSpells, currentPly);
                        if (isAttackerFrozen && piece.type.toLowerCase() !== 'k') {
                            continue; 
                        }
                        
                        const pieceType = piece.type.toLowerCase();
                        if (pieceType === 'p') {
                            const attackDR = (attackerColor === 'white') ? -1 : 1; 
                            if (r_attacker + attackDR === targetR && Math.abs(c_attacker - targetC) === 1) return true;
                        } else if (pieceType === 'n') {
                            const drAbs = Math.abs(targetR - r_attacker);
                            const dcAbs = Math.abs(targetC - c_attacker);
                            if ((drAbs === 2 && dcAbs === 1) || (drAbs === 1 && dcAbs === 2)) return true;
                        } else if (pieceType === 'r' || pieceType === 'q') { 
                            if ((r_attacker === targetR || c_attacker === targetC) && isPathClear(r_attacker, c_attacker, targetR, targetC, board)) {
                                return true;
                            }
                        } 
                        if (pieceType === 'b' || pieceType === 'q') { 
                             if (Math.abs(targetR - r_attacker) === Math.abs(targetC - c_attacker) && isPathClear(r_attacker, c_attacker, targetR, targetC, board)) {
                                return true;
                            }
                        }
                        if (pieceType === 'k') {
                            if (Math.abs(targetR - r_attacker) <= 1 && Math.abs(targetC - c_attacker) <= 1) return true;
                        }
                    }
                }
            }
            return false;
        }

        function checkCastleConditions(kingFromR, kingFromC, kingToR, kingToC, board, player, castlingRights, activeSpells, currentPly, enPassantTarget) {
            const opponentColor = player === 'white' ? 'black' : 'white';
            const king = board[kingFromR][kingFromC];

            if (!king || king.hasMoved) return false; 

            if (isKingInCheck(player, board, enPassantTarget, activeSpells, currentPly)) return false;

            const isKingside = kingToC > kingFromC;

            if (isKingside) {
                if (player === 'white' && !castlingRights.white.K) return false;
                if (player === 'black' && !castlingRights.black.k) return false;
                const rook = board[kingFromR][7];
                if (!rook || rook.type.toLowerCase() !== 'r' || rook.hasMoved) return false;


                if (board[kingFromR][kingFromC + 1] || board[kingFromR][kingFromC + 2]) return false;
                
                if (isSquareAttacked(kingFromR, kingFromC + 1, opponentColor, board, enPassantTarget, activeSpells, currentPly)) return false;
                if (isSquareAttacked(kingFromR, kingFromC + 2, opponentColor, board, enPassantTarget, activeSpells, currentPly)) return false;
            } else { // Queenside
                if (player === 'white' && !castlingRights.white.Q) return false;
                if (player === 'black' && !castlingRights.black.q) return false;
                const rook = board[kingFromR][0];
                if (!rook || rook.type.toLowerCase() !== 'r' || rook.hasMoved) return false;

                if (board[kingFromR][kingFromC - 1] || board[kingFromR][kingFromC - 2] || board[kingFromR][kingFromC - 3]) return false;
                
                if (isSquareAttacked(kingFromR, kingFromC - 1, opponentColor, board, enPassantTarget, activeSpells, currentPly)) return false;
                if (isSquareAttacked(kingFromR, kingFromC - 2, opponentColor, board, enPassantTarget, activeSpells, currentPly)) return false;
            }
            return true;
        }

        function isValidMove(fromR, fromC, toR, toC, board, currentPlayer, currentEnPassantTarget, currentCastlingRights, activeSpells, currentPly) {
            const movingPiece = board[fromR][fromC];
            if (!movingPiece || movingPiece.color !== currentPlayer) return false;

            let effectivelyFrozenMovingPiece = movingPiece.isFrozen || isSquareUnderActiveFreeze(fromR, fromC, activeSpells, currentPly);
            if (effectivelyFrozenMovingPiece) return false;

            if (fromR === toR && fromC === toC) return false; 

            const targetPiece = board[toR][toC];
            if (targetPiece && targetPiece.color === movingPiece.color) return false; 

            const pieceType = movingPiece.type.toLowerCase();

            if (pieceType === 'k' && Math.abs(toC - fromC) === 2 && fromR === toR) {
                return checkCastleConditions(fromR, fromC, toR, toC, board, currentPlayer, currentCastlingRights, activeSpells, currentPly, currentEnPassantTarget);
            }

            let isValidSpecificMove = false;
            switch (pieceType) {
                case 'p':
                    const colorMultiplier = (movingPiece.color === 'white') ? -1 : 1;
                    if (toR === fromR + colorMultiplier && toC === fromC && !targetPiece) { 
                        isValidSpecificMove = true;
                    } else if (toR === fromR + 2 * colorMultiplier && toC === fromC && !movingPiece.hasMoved && !targetPiece && !board[fromR + colorMultiplier][fromC]) { 
                        isValidSpecificMove = true;
                    } else if (toR === fromR + colorMultiplier && Math.abs(toC - fromC) === 1 && targetPiece && targetPiece.color !== movingPiece.color) { 
                        isValidSpecificMove = true;
                    } else if (toR === fromR + colorMultiplier && Math.abs(toC - fromC) === 1 && !targetPiece &&
                               currentEnPassantTarget && toR === currentEnPassantTarget.r && toC === currentEnPassantTarget.c) { 
                        const epCapturedPawnActualR = fromR;
                        const epCapturedPawnActualC = toC;
                        const pawnToCapture = board[epCapturedPawnActualR]?.[epCapturedPawnActualC];
                        if (pawnToCapture && pawnToCapture.type.toLowerCase() === 'p' && pawnToCapture.color !== movingPiece.color) {
                             isValidSpecificMove = true;
                        }
                    }
                    break;
                case 'n':
                    const drN = Math.abs(toR - fromR);
                    const dcN = Math.abs(toC - fromC);
                    if ((drN === 2 && dcN === 1) || (drN === 1 && dcN === 2)) {
                        isValidSpecificMove = true;
                    }
                    break;
                case 'b':
                    if (Math.abs(toR - fromR) === Math.abs(toC - fromC)) {
                        if (isPathClear(fromR, fromC, toR, toC, board)) isValidSpecificMove = true;
                    }
                    break;
                case 'r':
                    if (fromR === toR || fromC === toC) {
                        if (isPathClear(fromR, fromC, toR, toC, board)) isValidSpecificMove = true;
                    }
                    break;
                case 'q':
                    if ((fromR === toR || fromC === toC) || (Math.abs(toR - fromR) === Math.abs(toC - fromC))) {
                        if (isPathClear(fromR, fromC, toR, toC, board)) isValidSpecificMove = true;
                    }
                    break;
                case 'k': 
                    const drK = Math.abs(toR - fromR);
                    const dcK = Math.abs(toC - fromC);
                    if (drK <= 1 && dcK <= 1) {
                        isValidSpecificMove = true;
                    }
                    break;
            }

            if (!isValidSpecificMove) return false;

            const tempBoard = board.map(row => row.map(p => p ? {...p} : null));
            const pieceToMoveCopy = tempBoard[fromR][fromC]; 
            tempBoard[toR][toC] = pieceToMoveCopy;
            tempBoard[fromR][fromC] = null;

            if (pieceType === 'p' && currentEnPassantTarget && toR === currentEnPassantTarget.r && toC === currentEnPassantTarget.c && !targetPiece) { 
                 const epCapturedPawnActualR = fromR;
                 const epCapturedPawnActualC = toC;
                 if (tempBoard[epCapturedPawnActualR] && tempBoard[epCapturedPawnActualR][epCapturedPawnActualC]) { 
                    tempBoard[epCapturedPawnActualR][epCapturedPawnActualC] = null;
                 }
            }

            let kingPos;
            const currentPlayerKingType = currentPlayer === 'white' ? 'K' : 'k';
            for (let r_king = 0; r_king < 8; r_king++) { 
                for (let c_king = 0; c_king < 8; c_king++) {
                    if (tempBoard[r_king][c_king] && tempBoard[r_king][c_king].type === currentPlayerKingType) {
                        kingPos = { r: r_king, c: c_king };
                        break;
                    }
                }
                if (kingPos) break;
            }
            
            if (!kingPos) return true; 

            const opponentColor = currentPlayer === 'white' ? 'black' : 'white';
            if (isSquareAttacked(kingPos.r, kingPos.c, opponentColor, tempBoard, null, activeSpells, currentPly )) { 
                return false; 
            }

            return true;
        }
        
        function getValidMovesForPiece(r_piece, c_piece) { 
            const refinedValidMoves = [];
            for (let tr = 0; tr < 8; tr++) {
                for (let tc = 0; tc < 8; tc++) {
                     if (isValidMove(r_piece, c_piece, tr, tc, gameState.board, gameState.currentPlayer, gameState.enPassantTarget, gameState.castlingRights, gameState.activeSpells, gameState.plyCount)) {
                        refinedValidMoves.push({ fromR: r_piece, fromC: c_piece, toR: tr, toC: tc });
                    }
                }
            }
            return refinedValidMoves;
        }

        function isKingInCheck(kingColor, board, enPassantTarget, activeSpells, currentPly) {
            let kingPos = null;
            const kingType = (kingColor === 'white') ? 'K' : 'k';
            const attackerColor = (kingColor === 'white') ? 'black' : 'white';

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const pieceOnSquare = board[r][c];
                    if (pieceOnSquare && pieceOnSquare.type === kingType) {
                        kingPos = { r, c };
                        break;
                    }
                }
                if (kingPos) break;
            }

            if (!kingPos) return false; 
            
            return isSquareAttacked(kingPos.r, kingPos.c, attackerColor, board, enPassantTarget, activeSpells, currentPly);
        }

        function hasLegalMoves(playerColor, board, enPassantTarget, currentCastlingRights, activeSpells, currentPly, playerSpellsState, playerGameTurnNumber) {
            // 1. Check for standard legal moves
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece.color === playerColor) { 
                        let isPieceEffectivelyFrozen = isSquareUnderActiveFreeze(r, c, activeSpells, currentPly);
                        if(isPieceEffectivelyFrozen) continue;

                        for (let toR = 0; toR < 8; toR++) {
                            for (let toC = 0; toC < 8; toC++) {
                                if (isValidMove(r, c, toR, toC, board, playerColor, enPassantTarget, currentCastlingRights, activeSpells, currentPly)) {
                                    return true; 
                                }
                            }
                        }
                    }
                }
            }

            if (!isKingInCheck(playerColor, board, enPassantTarget, activeSpells, currentPly)) {
                return false; 
            }

            // 2. Check Jump Spell
            const canCastJump = playerSpellsState.jump > 0 && (playerSpellsState.jumpLastUsedTurn === 0 || playerGameTurnNumber >= playerSpellsState.jumpLastUsedTurn + 3);
            if (canCastJump) {
                for (let jr = 0; jr < 8; jr++) { 
                    for (let jc = 0; jc < 8; jc++) {
                        const targetPieceForJump = board[jr][jc];
                        if (targetPieceForJump) {
                            const originalIsJumpable = targetPieceForJump.isJumpable;
                            targetPieceForJump.isJumpable = true;
                            
                            const tempBoardForJumpCheck = board.map(row => row.map(p => p ? {...p} : null)); // Simulate jump on a copy
                            tempBoardForJumpCheck[jr][jc].isJumpable = true;

                            if (!isKingInCheck(playerColor, tempBoardForJumpCheck, enPassantTarget, activeSpells, currentPly)) {
                                for (let r = 0; r < 8; r++) {
                                    for (let c = 0; c < 8; c++) {
                                        const piece = tempBoardForJumpCheck[r][c];
                                        if (piece && piece.color === playerColor) {
                                            if (isSquareUnderActiveFreeze(r, c, activeSpells, currentPly)) continue;
                                            for (let toR = 0; toR < 8; toR++) {
                                                for (let toC = 0; toC < 8; toC++) {
                                                    if (isValidMove(r, c, toR, toC, tempBoardForJumpCheck, playerColor, enPassantTarget, currentCastlingRights, activeSpells, currentPly)) {
                                                        targetPieceForJump.isJumpable = originalIsJumpable; 
                                                        return true; 
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            targetPieceForJump.isJumpable = originalIsJumpable; 
                        }
                    }
                }
            }

            // 3. Check Freeze Spell
            const canCastFreeze = playerSpellsState.freeze > 0 && (playerSpellsState.freezeLastUsedTurn === 0 || playerGameTurnNumber >= playerSpellsState.freezeLastUsedTurn + 3);
            if (canCastFreeze) {
                for (let fr = 0; fr < 8; fr++) { 
                    for (let fc = 0; fc < 8; fc++) {
                        const tempActiveSpells = JSON.parse(JSON.stringify(activeSpells || [])); 
                        tempActiveSpells.push({
                            type: 'freeze',
                            targetSquare: { r: fr, c: fc },
                            expiresAtPly: currentPly + 1 
                        });

                        if (!isKingInCheck(playerColor, board, enPassantTarget, tempActiveSpells, currentPly)) {
                            for (let r = 0; r < 8; r++) {
                                for (let c = 0; c < 8; c++) {
                                    const piece = board[r][c];
                                    if (piece && piece.color === playerColor) {
                                        if (isSquareUnderActiveFreeze(r, c, tempActiveSpells, currentPly)) continue;
                                        
                                        for (let toR = 0; toR < 8; toR++) {
                                            for (let toC = 0; toC < 8; toC++) {
                                                if (isValidMove(r, c, toR, toC, board, playerColor, enPassantTarget, currentCastlingRights, tempActiveSpells, currentPly)) {
                                                    return true; 
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false; 
        }

        function generateMoveNotation(piece, fromR, fromC, toR, toC, capturedPiece, isEnPassant = false) {
            let notation = "";
            const pieceTypeUpper = piece.type.toUpperCase();

            if (pieceTypeUpper !== 'P') {
                notation += pieceTypeUpper;
            } else if (capturedPiece && !isEnPassant) { 
                notation += String.fromCharCode(97 + fromC);
            } else if (isEnPassant){
                 notation += String.fromCharCode(97 + fromC);
            }
            
            const toFile = String.fromCharCode(97 + toC);
            const toRank = 8 - toR;

            if (capturedPiece) {
                notation += 'x';
            }
            notation += toFile + toRank;

            if (isEnPassant) {
                notation += " e.p."; 
            }
            return notation;
        }
        
        function handleSpellTargeting(r_target, c_target) { 
            const targetPiece = gameState.board[r_target][c_target];
            let spellApplied = false;
            let spellNotation = "";
            const spellCaster = gameState.spellCaster; 
            const playerSpells = gameState.spells[spellCaster];
            const currentCastingGameTurn = gameState.gameTurnNumber; 

            if (gameState.spellMode === 'jump') {
                if (targetPiece) {
                    playerSpells.jump--;
                    playerSpells.jumpLastUsedTurn = currentCastingGameTurn; 
                    
                    gameState.activeSpells.push({
                        type: 'jump',
                        targetId: targetPiece.id,
                        expiresAtPly: gameState.plyCount + 2 
                    });
                    targetPiece.isJumpable = true; 
                    spellApplied = true;
                    spellNotation = `jump@${String.fromCharCode(97 + c_target)}${8 - r_target}`;
                    updateStatus(`${spellCaster.charAt(0).toUpperCase() + spellCaster.slice(1)} cast Jump on ${PIECES[targetPiece.type]} at ${String.fromCharCode(97 + c_target)}${8 - r_target}. Make your move.`);
                } else {
                    updateStatus("Jump spell must target a piece. Select a piece to Jump or Cancel.");
                    renderBoard(); 
                    updateCancelButtonVisibility(); 
                    return; 
                }
            } else if (gameState.spellMode === 'freeze') {
                playerSpells.freeze--;
                playerSpells.freezeLastUsedTurn = currentCastingGameTurn;

                const affectedPieceIds = [];
                const freezeCenterR = r_target;
                const freezeCenterC = c_target;
                
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        const nr = freezeCenterR + dr; 
                        const nc = freezeCenterC + dc; 
                        if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) { 
                            const pieceToFreeze = gameState.board[nr][nc];
                            if (pieceToFreeze) {
                                affectedPieceIds.push(pieceToFreeze.id);
                            }
                        }
                    }
                }
                gameState.activeSpells.push({
                    type: 'freeze',
                    targetSquare: {r: freezeCenterR, c: freezeCenterC}, 
                    affectedPieceIds: affectedPieceIds, 
                    expiresAtPly: gameState.plyCount + 2 
                });
                spellApplied = true;
                spellNotation = `freeze@${String.fromCharCode(97 + c_target)}${8 - r_target}`;
                updateStatus(`${spellCaster.charAt(0).toUpperCase() + spellCaster.slice(1)} cast Freeze around ${String.fromCharCode(97 + c_target)}${8 - r_target}. Make your move.`);
            }

            if (spellApplied) {
                gameState.pendingSpellNotation = spellNotation;
                gameState.spellMode = null; 
            }
            renderBoard(); 
            updateSpellControls();
            updateCancelButtonVisibility();
        }

        function activateSpellMode(type) {
            if (gameState.selectedPiece) { 
                gameState.selectedPiece = null;
            }

            if (gameState.isGameOver || gameState.awaitingPromotion) return; 
            if (gameState.spellMode && gameState.spellMode !== type && gameState.spellCaster === gameState.currentPlayer) { 
                updateStatus("Another spell is already being targeted. Cancel it first.");
                return;
            }
             if (gameState.spellMode === type && gameState.spellCaster === gameState.currentPlayer) { 
                handleCancelAction(); 
                return;
            }
            if (gameState.pendingSpellNotation) { 
                updateStatus("You have already cast a spell this turn. Make your move or Cancel the cast spell.");
                return;
            }

            const playerSpells = gameState.spells[gameState.currentPlayer];
            const currentTurnForPlayerForCooldownCheck = gameState.gameTurnNumber;
            let count, lastUsedTurn, spellName;

            if (type === 'jump') {
                count = playerSpells.jump;
                lastUsedTurn = playerSpells.jumpLastUsedTurn;
                spellName = "Jump";
            } else { 
                count = playerSpells.freeze;
                lastUsedTurn = playerSpells.freezeLastUsedTurn;
                spellName = "Freeze";
            }

            if (count <= 0) {
                updateStatus(`No ${spellName} spells left.`);
                return;
            }
            if (lastUsedTurn > 0 && currentTurnForPlayerForCooldownCheck < lastUsedTurn + 3) { 
                updateStatus(`${spellName} spell is on cooldown. Available on game turn ${lastUsedTurn + 3}.`);
                return;
            }

            gameState.spellMode = type;
            gameState.spellCaster = gameState.currentPlayer;
            gameState.spellActivationState = { 
                type: type,
                originalLastUsedTurn: lastUsedTurn 
            };
            
            updateStatus(`${gameState.currentPlayer.charAt(0).toUpperCase() + gameState.currentPlayer.slice(1)} is casting ${spellName}. Select target on board or Cancel.`);
            cancelButton.textContent = "Cancel Spell";
            renderBoard(); 
            updateSpellControls(); 
            updateCancelButtonVisibility(); 
        }

        function handleCancelAction() {
            if (gameState.awaitingPromotion) {
                updateStatus("Choose a promotion piece.");
                return;
            }

            let playerDisplayTurn = "";
            const caster = gameState.spellCaster || gameState.currentPlayer; 
            if (caster) {
                 playerDisplayTurn = `${caster.charAt(0).toUpperCase() + caster.slice(1)}'s turn. `;
            }

            if (gameState.pendingSpellNotation) { 
                const playerToRefund = gameState.spellCaster; 
                const playerSpells = gameState.spells[playerToRefund];
                let cancelledSpellType = "";

                if (gameState.pendingSpellNotation.startsWith('jump@')) {
                    cancelledSpellType = 'jump';
                } else if (gameState.pendingSpellNotation.startsWith('freeze@')) {
                    cancelledSpellType = 'freeze';
                }

                let spellIndexToRemove = -1;
                for (let i = gameState.activeSpells.length - 1; i >= 0; i--) {
                    const spell = gameState.activeSpells[i];
                    if (spell.type === cancelledSpellType && spell.expiresAtPly === gameState.plyCount + 2) { 
                        spellIndexToRemove = i;
                        break;
                    }
                }
                
                if (spellIndexToRemove !== -1) {
                    const spellToCancel = gameState.activeSpells[spellIndexToRemove];
                    if (cancelledSpellType === 'jump') {
                        const jumpedPiece = findPieceById(spellToCancel.targetId);
                        if (jumpedPiece) jumpedPiece.isJumpable = false;
                        playerSpells.jump++;
                        if (gameState.spellActivationState && gameState.spellActivationState.type === 'jump') {
                            playerSpells.jumpLastUsedTurn = gameState.spellActivationState.originalLastUsedTurn;
                        }
                    } else if (cancelledSpellType === 'freeze') {
                        playerSpells.freeze++;
                        if (gameState.spellActivationState && gameState.spellActivationState.type === 'freeze') {
                            playerSpells.freezeLastUsedTurn = gameState.spellActivationState.originalLastUsedTurn;
                        }
                    }
                    gameState.activeSpells.splice(spellIndexToRemove, 1);
                }

                gameState.pendingSpellNotation = null;
                updateStatus(`${playerDisplayTurn}Spell cancelled.`);

            } else if (gameState.spellMode) { 
                updateStatus(`${playerDisplayTurn}Spell targeting cancelled.`);
            }

            gameState.spellMode = null;
            gameState.spellCaster = null;
            gameState.spellActivationState = null;
            cancelButton.textContent = "Cancel"; 

            renderBoard();
            updateSpellControls();
            updateCancelButtonVisibility();
        }
        
        function updateActiveSpells() {
            const stillActive = [];
            let boardNeedsRender = false;

            gameState.activeSpells.forEach(spell => {
                if (gameState.plyCount >= spell.expiresAtPly) { 
                    if (spell.type === 'freeze') {
                        // Visual effect of freeze zone is handled by renderBoard
                    } else if (spell.type === 'jump') {
                         const piece = findPieceById(spell.targetId);
                         if (piece) piece.isJumpable = false;
                    }
                    boardNeedsRender = true; 
                } else {
                    stillActive.push(spell); 
                }
            });
            gameState.activeSpells = stillActive; 
            
            if (boardNeedsRender) renderBoard(); 
        }

        function findPieceById(id) {
            for (let r_find = 0; r_find < 8; r_find++) { 
                for (let c_find = 0; c_find < 8; c_find++) {
                    if (gameState.board[r_find][c_find] && gameState.board[r_find][c_find].id === id) {
                        return gameState.board[r_find][c_find];
                    }
                }
            }
            return null;
        }

        function endTurn(moveNotation, movedPiece, fromR_param, toR_param, fromC_param) {
            const playerWhoMoved = gameState.currentPlayer; 
            
            gameState.plyCount++; 
            updateActiveSpells(); 

            let gameEndMessage = "";
            let isCheck = false;
            let isCheckmate = false;

            const opponentColor = (playerWhoMoved === 'white') ? 'black' : 'white';
            const opponentKingStillExists = gameState.board.flat().some(p => p && p.type.toLowerCase() === 'k' && p.color === opponentColor);

            if (!opponentKingStillExists) {
                isCheckmate = true; 
                gameState.isGameOver = true;
                const winner = playerWhoMoved.charAt(0).toUpperCase() + playerWhoMoved.slice(1);
                gameEndMessage = `King captured! ${winner} wins!`;
            } else {
                if (isKingInCheck(opponentColor, gameState.board, gameState.enPassantTarget, gameState.activeSpells, gameState.plyCount)) {
                    isCheck = true;
                    const nextPlayerSpells = gameState.spells[opponentColor];
                    if (!hasLegalMoves(opponentColor, gameState.board, gameState.enPassantTarget, gameState.castlingRights, gameState.activeSpells, gameState.plyCount, nextPlayerSpells, gameState.gameTurnNumber)) {
                        isCheckmate = true;
                        gameState.isGameOver = true;
                        const winner = playerWhoMoved.charAt(0).toUpperCase() + playerWhoMoved.slice(1);
                        gameEndMessage = `Checkmate! ${winner} wins!`;
                    }
                } else { 
                    const nextPlayerSpells = gameState.spells[opponentColor];
                    if (!hasLegalMoves(opponentColor, gameState.board, gameState.enPassantTarget, gameState.castlingRights, gameState.activeSpells, gameState.plyCount, nextPlayerSpells, gameState.gameTurnNumber)) {
                        gameState.isGameOver = true;
                        gameEndMessage = "Stalemate! Draw.";
                    }
                }
            }
            
            let finalMoveNotationWithSymbols = gameState.pendingSpellNotation ? gameState.pendingSpellNotation + " " + moveNotation : moveNotation;
            if (isCheckmate) {
                finalMoveNotationWithSymbols += "#";
            } else if (isCheck) {
                finalMoveNotationWithSymbols += "+";
            }
            gameState.pendingSpellNotation = null;

            let next_currentPlayer_state = gameState.currentPlayer; 
            let next_gameTurnNumber_state = gameState.gameTurnNumber;
            let next_whitePlayerTurn_state = gameState.whitePlayerTurn;
            let next_blackPlayerTurn_state = gameState.blackPlayerTurn;

            if (!gameState.isGameOver) {
                if (playerWhoMoved === 'white') { 
                    next_currentPlayer_state = 'black';
                    next_blackPlayerTurn_state = gameState.blackPlayerTurn + 1; 
                } else { 
                    next_currentPlayer_state = 'white';
                    next_whitePlayerTurn_state = gameState.whitePlayerTurn + 1;
                    next_gameTurnNumber_state = gameState.gameTurnNumber + 1;
                }
            }
            
            const stateToSnapshot = deepCopyGameStateForSnapshot(gameState); 
            stateToSnapshot.currentPlayer = next_currentPlayer_state;
            stateToSnapshot.gameTurnNumber = next_gameTurnNumber_state; 
            stateToSnapshot.whitePlayerTurn = next_whitePlayerTurn_state;
            stateToSnapshot.blackPlayerTurn = next_blackPlayerTurn_state;
            stateToSnapshot.plyCount = gameState.plyCount; 
            stateToSnapshot.gameEndMessage = gameState.isGameOver ? gameEndMessage : "";
            stateToSnapshot.useStandardPieces = useStandardPieces; 
            gameState.history.push(stateToSnapshot); 
            
            gameState.moveLog.push({ 
                turn: gameState.gameTurnNumber, 
                player: playerWhoMoved, 
                notation: finalMoveNotationWithSymbols, 
                plySnapshotIndex: gameState.plyCount 
            });
            
            gameState.enPassantTarget = null; 
            if (movedPiece?.type.toLowerCase() === 'p' && Math.abs(fromR_param - toR_param) === 2) {
                gameState.enPassantTarget = { r: (fromR_param + toR_param) / 2, c: fromC_param };
            }
            gameState.spellActivationState = null; 
            gameState.spellCaster = null; 
            
            updateNotationDisplay(); 

            if (gameState.isGameOver) {
                updateStatus(gameEndMessage);
            } else { 
                gameState.currentPlayer = next_currentPlayer_state;
                gameState.gameTurnNumber = next_gameTurnNumber_state;
                gameState.whitePlayerTurn = next_whitePlayerTurn_state;
                gameState.blackPlayerTurn = next_blackPlayerTurn_state;
                updateStatus(`${gameState.currentPlayer.charAt(0).toUpperCase() + gameState.currentPlayer.slice(1)}'s turn.` + (isCheck ? " Check!" : ""));
            }
            
            updateSpellControls();
            updateCancelButtonVisibility(); 
            renderBoard(); 
        }
        
        function handleNotationClick(plySnapshotIndex) {
            if (gameState.awaitingPromotion) { 
                updateStatus("Please choose a promotion piece first.");
                return;
            }
            if (plySnapshotIndex < 0 || plySnapshotIndex >= gameState.history.length) {
                console.error("Invalid plySnapshotIndex for history:", plySnapshotIndex);
                return;
            }

            const targetStateSnapshot = gameState.history[plySnapshotIndex];
            if (!targetStateSnapshot) {
                 console.error("No state found in history for index:", plySnapshotIndex);
                 return;
            }
            
            const currentPieceStyleBeforeLoad = useStandardPieces; 

            const keysToRestore = [
                'board', 'currentPlayer', 'gameTurnNumber', 'whitePlayerTurn', 
                'blackPlayerTurn', 'plyCount', 'spells', 'activeSpells', 
                'selectedPiece', 'spellMode', 'spellCaster', 'spellActivationState',
                'pendingSpellNotation', 'enPassantTarget', 'castlingRights', 
                'isGameOver', 'gameEndMessage', 'awaitingPromotion', 'useStandardPieces' 
            ];

            for (const key of keysToRestore) {
                if (Object.prototype.hasOwnProperty.call(targetStateSnapshot, key)) {
                    if (typeof targetStateSnapshot[key] === 'object' && targetStateSnapshot[key] !== null) {
                        gameState[key] = JSON.parse(JSON.stringify(targetStateSnapshot[key]));
                    } else {
                        gameState[key] = targetStateSnapshot[key];
                    }
                }
            }
            
            useStandardPieces = gameState.useStandardPieces === undefined ? currentPieceStyleBeforeLoad : gameState.useStandardPieces;
            
            gameState.history = gameState.history.slice(0, plySnapshotIndex + 1);
            gameState.moveLog = gameState.moveLog.filter(logEntry => logEntry.plySnapshotIndex <= plySnapshotIndex);

            applyPieceStyle(); 
            updateSpellControls();
            updateCancelButtonVisibility(); 
            updateNotationDisplay();    

            if (gameState.isGameOver) {
                updateStatus(gameState.gameEndMessage || "Game over at this point.");
            } else if (gameState.awaitingPromotion) {
                 updateStatus(`Choose promotion for pawn at ${String.fromCharCode(97 + gameState.awaitingPromotion.c)}${8 - gameState.awaitingPromotion.r}.`);
            }
            else {
                let statusMsg = `${gameState.currentPlayer.charAt(0).toUpperCase() + gameState.currentPlayer.slice(1)}'s turn.`;
                if (gameState.board && gameState.board.length > 0 && 
                    isKingInCheck(gameState.currentPlayer, gameState.board, gameState.enPassantTarget, gameState.activeSpells, gameState.plyCount)) {
                    statusMsg += " Check!";
                }
                updateStatus(statusMsg);
            }
        }

        function updateNotationDisplay() {
            notationArea.innerHTML = ''; 
            let currentTurnDiv = null;
            let lastTurnNumberProcessed = 0;

            gameState.moveLog.forEach(moveEntry => {
                if (moveEntry.turn !== lastTurnNumberProcessed) {
                    if (currentTurnDiv) {
                        notationArea.appendChild(currentTurnDiv);
                    }
                    currentTurnDiv = document.createElement('div');
                    currentTurnDiv.classList.add('notation-line');
                    
                    const turnNumSpan = document.createElement('span');
                    turnNumSpan.classList.add('notation-turn-number');
                    turnNumSpan.textContent = `${moveEntry.turn}. `; 
                    currentTurnDiv.appendChild(turnNumSpan);
                    lastTurnNumberProcessed = moveEntry.turn;
                }

                const moveSpan = document.createElement('span');
                moveSpan.classList.add('notation-move');
                moveSpan.textContent = moveEntry.notation; 
                moveSpan.dataset.plySnapshotIndex = moveEntry.plySnapshotIndex;
                moveSpan.addEventListener('click', () => handleNotationClick(parseInt(moveSpan.dataset.plySnapshotIndex)));
                
                if (currentTurnDiv) { 
                    currentTurnDiv.appendChild(moveSpan);
                    currentTurnDiv.appendChild(document.createTextNode(' ')); 
                }
            });

            if (currentTurnDiv) { 
                notationArea.appendChild(currentTurnDiv);
            }

            if (gameState.moveLog.length === 0) { 
                notationArea.innerHTML = ""; 
            }
            notationArea.scrollTop = notationArea.scrollHeight;
        }

        function updateStatus(message) {
            statusArea.textContent = message;
        }
        
        function updateCancelButtonVisibility() {
            if (gameState.awaitingPromotion) {
                cancelButton.style.display = 'none';
                promotionChoicesDiv.style.display = 'flex';
                return;
            }
            promotionChoicesDiv.style.display = 'none';

            if (!gameState.isGameOver && (gameState.spellMode || gameState.pendingSpellNotation)) {
                cancelButton.style.display = 'block';
                if (gameState.spellMode || gameState.pendingSpellNotation) { 
                    cancelButton.textContent = "Cancel Spell";
                } else {
                    cancelButton.textContent = "Cancel"; 
                }
            } else {
                cancelButton.style.display = 'none';
                cancelButton.textContent = "Cancel"; 
            }
        }

        function updateSpellControls() {
            const disableControls = gameState.awaitingPromotion || gameState.isGameOver;

            ['white', 'black'].forEach(player => {
                const spells = gameState.spells[player];
                const currentCastingGameTurnForCheck = gameState.gameTurnNumber;

                const jumpBtn = document.getElementById(`${player}-jump-spell`);
                const jumpCooldownEl = document.getElementById(`${player}-jump-cooldown`);
                document.getElementById(`${player}-jump-count`).textContent = spells.jump;
                
                let jumpDisabled = disableControls || 
                                   player !== gameState.currentPlayer || 
                                   spells.jump === 0 || 
                                   !!gameState.pendingSpellNotation ||
                                   (gameState.spellMode && gameState.spellMode !== 'jump' && gameState.spellCaster === player);
                let jumpCooldownText = spells.jump > 0 ? "Ready" : "No spells left";

                if (spells.jumpLastUsedTurn > 0 && currentCastingGameTurnForCheck < spells.jumpLastUsedTurn + 3) {
                    jumpDisabled = true; 
                    jumpCooldownText = `Cooldown until game turn ${spells.jumpLastUsedTurn + 3}`;
                }
                jumpBtn.disabled = jumpDisabled;
                jumpCooldownEl.textContent = jumpCooldownText;
                jumpBtn.classList.toggle('targeting', !disableControls && gameState.spellMode === 'jump' && gameState.spellCaster === player);

                const freezeBtn = document.getElementById(`${player}-freeze-spell`);
                const freezeCooldownEl = document.getElementById(`${player}-freeze-cooldown`);
                document.getElementById(`${player}-freeze-count`).textContent = spells.freeze;

                let freezeDisabled = disableControls || 
                                     player !== gameState.currentPlayer || 
                                     spells.freeze === 0 || 
                                     !!gameState.pendingSpellNotation ||
                                     (gameState.spellMode && gameState.spellMode !== 'freeze' && gameState.spellCaster === player);
                let freezeCooldownText = spells.freeze > 0 ? "Ready" : "No spells left";

                if (spells.freezeLastUsedTurn > 0 && currentCastingGameTurnForCheck < spells.freezeLastUsedTurn + 3) {
                    freezeDisabled = true;
                    freezeCooldownText = `Cooldown until game turn ${spells.freezeLastUsedTurn + 3}`;
                }
                freezeBtn.disabled = freezeDisabled;
                freezeCooldownEl.textContent = freezeCooldownText;
                freezeBtn.classList.toggle('targeting', !disableControls && gameState.spellMode === 'freeze' && gameState.spellCaster === player);
            });
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const savedDataScript = document.getElementById('savedGameStateData');
            const mainBody = document.body; 

            if (savedDataScript && savedDataScript.textContent.trim() !== "") {
                try {
                    initialGameDataFromSave = JSON.parse(savedDataScript.textContent);
                    mainBody.classList.remove('home-view'); 
                    mainBody.classList.add('game-view');
                } catch (e) {
                    console.error("Error parsing saved game data:", e);
                    initialGameDataFromSave = null;
                }
            }
            resetGame(); 
        });
        
        document.getElementById('white-jump-spell').addEventListener('click', () => activateSpellMode('jump'));
        document.getElementById('white-freeze-spell').addEventListener('click', () => activateSpellMode('freeze'));
        document.getElementById('black-jump-spell').addEventListener('click', () => activateSpellMode('jump'));
        document.getElementById('black-freeze-spell').addEventListener('click', () => activateSpellMode('freeze'));

    </script>


</body></html>
